{"version":3,"file":"lrud.cjs.development.js","sources":["../src/utils/warning.ts","../src/utils/clamp.ts","../src/utils/get-index.ts","../src/utils/create-node.ts","../src/utils/node-id-is-focused.ts","../src/utils/node-can-receive-indirect-focus.ts","../src/utils/tree-navigation.ts","../src/update-focus/compute-focus-hierarchy.ts","../src/update-focus/get-focus-diff.ts","../src/update-focus/get-nodes-from-focus-change.ts","../src/update-focus/bubble-focus-event.ts","../src/update-focus/emit-focus-state-events.ts","../src/update-focus/update-focus.ts","../src/utils/delete-node.ts","../src/handle-arrow/default-navigation/navigate-from-target-node.ts","../src/handle-arrow/default-navigation/default-navigation.ts","../src/utils/get-grid-focus-data.ts","../src/handle-arrow/grid-navigation/grid-navigation.ts","../src/handle-arrow/determine-navigation-style/get-grid-parent.ts","../src/handle-arrow/determine-navigation-style/test-for-grid.ts","../src/handle-arrow/determine-navigation-style/get-default-nav-target.ts","../src/handle-arrow/determine-navigation-style/determine-navigation-style.ts","../src/handle-arrow/handle-arrow.ts","../src/utils/enforce-state-structure.ts","../src/utils/recursively-update-node.ts","../src/utils/bubble-key-input.ts","../src/focus-store.ts","../src/lrud-input/throttle.ts","../src/lrud-input/key-to-binding-map.ts","../src/lrud-input/focus-lrud.ts","../src/focus-context.tsx","../src/utils/node-from-definition.ts","../src/hooks/internal/use-previous.ts","../src/focus-node.tsx","../src/hooks/use-focus-node-by-id.ts","../src/hooks/use-focus-node.ts","../src/hooks/use-focus-hierarchy.ts","../src/hooks/use-leaf-focused-node.ts","../src/hooks/use-active-node.ts","../src/hooks/use-focus-store-dangerously.ts","../src/hooks/use-set-focus.ts","../src/hooks/internal/use-on-change.ts","../src/hooks/use-focus-events.ts","../src/hooks/use-process-key.ts","../src/index.ts"],"sourcesContent":["interface CodeCache {\n  [key: string]: boolean;\n}\n\nlet codeCache: CodeCache = {};\n\nexport function warning(message: string, code?: string) {\n  // This ensures that each warning type is only logged out one time\n  if (code) {\n    if (codeCache[code]) {\n      return;\n    }\n\n    codeCache[code] = true;\n  }\n\n  if (typeof console !== 'undefined' && typeof console.error === 'function') {\n    console.error(message);\n  }\n\n  try {\n    // This error was thrown as a convenience so that if you enable\n    // \"break on all exceptions\" in your console,\n    // it would pause the execution at this line.\n    throw new Error(message);\n  } catch (e) {\n    // Intentionally blank\n  }\n}\n\nexport function resetCodeCache() {\n  codeCache = {};\n}\n","// From Sindre's math-clamp library\n// https://github.com/sindresorhus/math-clamp\n// License: https://github.com/sindresorhus/math-clamp/blob/9f17aa114bbdaa99f6ce62f2fed860acaab4d00b/license\n//\n// Will one day be replaced with:\n// https://github.com/rwaldron/proposal-math-extensions\nexport default function clamp(x: number, min: number, max: number): number {\n  if (min > max) {\n    throw new RangeError('`min` should be lower than `max`');\n  }\n\n  if (x < min) {\n    return min;\n  }\n\n  if (x > max) {\n    return max;\n  }\n\n  return x;\n}\n","import clamp from './clamp';\n\nfunction getWrappedIndex(index: number, size: number): number {\n  return index - Math.floor(index / size) * size;\n}\n\nexport default function getIndex(\n  arrayLength: number,\n  index: number,\n  wrap: boolean = false\n) {\n  if (wrap) {\n    return getWrappedIndex(index, arrayLength);\n  } else {\n    return clamp(index, 0, arrayLength - 1);\n  }\n}\n","import { warning } from '../utils/warning';\nimport { NodeDefinition, FocusState, NodeMap, Id, Node } from '../types';\nimport getIndex from './get-index';\n\ninterface createNodeDefinitionHierarchyState {\n  focusState: FocusState;\n  nodeDefinitionHierarchy: NodeDefinition[];\n  nodeHierarchy: Node[];\n}\n\ninterface createNodeDefinitionHierarchyReturn {\n  nodes: NodeMap | null;\n  assignFocusTo: Id | null;\n  shouldLockFocus: boolean;\n}\n\nexport default function createNodeDefinitionHierarchy({\n  focusState,\n  nodeDefinitionHierarchy,\n  nodeHierarchy,\n}: createNodeDefinitionHierarchyState): createNodeDefinitionHierarchyReturn {\n  const nodeUpdates: NodeMap = {};\n\n  let onMountAssignFocusToReturn: Id | null = null;\n  let onMountAssignFocusTo: Id | null = null;\n  let shouldLockFocus = focusState._updatingFocusIsLocked;\n\n  for (let i = 0; i < nodeDefinitionHierarchy.length; i++) {\n    const node = nodeHierarchy[i];\n    const isLastNode = i === nodeDefinitionHierarchy.length - 1;\n\n    const nodeDefinition = nodeDefinitionHierarchy[i];\n    const currentNode = focusState.nodes[nodeDefinition.focusId];\n    const isCreatingNewNode = !currentNode;\n\n    if (nodeDefinition.onMountAssignFocusTo !== undefined) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (onMountAssignFocusTo !== null) {\n          warning(\n            '[Focus]: More than one onMountAssignFocusTo was encountered while creating a new focus subtree. This may represent an error in your code. ' +\n              'We strongly encourage you to ensure that only a single node is assigned an onMountAssignFocusTo when creating a focus subtree. ' +\n              'Your onMountAssignFocusTo has been ignored, and the first child will be assigned focus.',\n            'MORE_THAN_ONE_ONMOUNTFOCUS'\n          );\n        }\n      }\n\n      onMountAssignFocusTo = nodeDefinition.onMountAssignFocusTo;\n\n      // We only actually assign the focus when this thing happens\n      if (isLastNode) {\n        // We disable the focus lock whenever we \"apply\" an `onMountAssignFocusTo`\n        shouldLockFocus = false;\n        onMountAssignFocusToReturn = nodeDefinition.onMountAssignFocusTo;\n      } else {\n        shouldLockFocus = true;\n      }\n    }\n\n    if (\n      nodeDefinition.navigationStyle === 'grid' &&\n      (nodeDefinition.defaultFocusColumn || nodeDefinition.defaultFocusRow)\n    ) {\n      if (isLastNode) {\n        shouldLockFocus = false;\n        const gridNode = focusState.nodes[node.focusId];\n\n        if (gridNode) {\n          const rowIndex = getIndex(\n            gridNode.children.length,\n            nodeDefinition.defaultFocusRow ?? 0,\n            gridNode.wrapGridVertical\n          );\n\n          const newRowNodeId = gridNode.children[rowIndex];\n          const rowNode = focusState.nodes[newRowNodeId];\n\n          // TODO: fix this\n          const rowNodeChildrenLength = rowNode?.children?.length ?? 0;\n\n          const columnIndex = getIndex(\n            rowNodeChildrenLength,\n            nodeDefinition.defaultFocusColumn ?? 0,\n            gridNode.wrapGridHorizontal\n          );\n\n          const itemIndex = Math.min(\n            columnIndex,\n            Math.max(rowNodeChildrenLength - 1, 0)\n          );\n          const focusedItemId = rowNode?.children[itemIndex];\n\n          if (focusedItemId) {\n            onMountAssignFocusToReturn = focusedItemId;\n          }\n        }\n      } else {\n        shouldLockFocus = true;\n        // TODO: warn. This is likely a bug.\n      }\n    }\n\n    // If we already have the node, then there is nothing else to do, so we bail\n    // (after checking for errors)\n    if (!isCreatingNewNode) {\n      // NOTE: this check *requires* that this API follow the `useEffect` order of React.\n      // The implementation of this feature ties this library very tightly with React.\n      const isFinalNode = i === nodeDefinitionHierarchy.length - 1;\n      const setFocusGoal = nodeDefinition.onMountAssignFocusTo;\n      if (process.env.NODE_ENV !== 'production') {\n        if (isFinalNode && setFocusGoal && !focusState.nodes[setFocusGoal]) {\n          warning(\n            'You configured an onMountAssignFocusTo that was not found in the focus tree. This may represent an error in your application. ' +\n              'Please make sure that the node specified by onMountAssignFocusTo is created at the same time as the parent.',\n            'NOT_FOUND_ON_MOUNT_FOCUS'\n          );\n        }\n      }\n\n      continue;\n    }\n\n    const parentLoopIndex = i - 1;\n    const parentDefinition = nodeDefinitionHierarchy[parentLoopIndex];\n    const parentId = parentDefinition.focusId;\n\n    const parentNode = (focusState.nodes[parentId] ||\n      nodeUpdates[parentId]) as unknown as Node;\n\n    const parentChildren = parentNode.children;\n\n    const newParentChildren = Array.isArray(parentChildren)\n      ? parentChildren.concat(nodeDefinition.focusId)\n      : [nodeDefinition.focusId];\n\n    nodeUpdates[parentId] = {\n      ...parentNode,\n      children: newParentChildren,\n    };\n\n    nodeUpdates[nodeDefinition.focusId] = node;\n  }\n\n  return {\n    nodes: Object.keys(nodeUpdates).length ? nodeUpdates : null,\n    assignFocusTo: onMountAssignFocusToReturn,\n    shouldLockFocus,\n  };\n}\n","import { NodeHierarchy, Id } from '../types';\n\nexport default function nodeIdIsFocused(\n  focusHierarchy: NodeHierarchy,\n  nodeId: Id\n) {\n  const idIndex = focusHierarchy.indexOf(nodeId);\n  return idIndex !== -1;\n}\n","import { FocusState, Node } from '../types';\n\n// \"Indirect focus\" here means:\n// 1. receiving focus when a parent node receives focus, either through LRUD input or through an explicit call\n//    to `setFocus`\n// 2. receiving focus after being mounted\n//\n// This function ensures that things like disabled nodes don't receive focus when LRUD is input or when they mount.\n\nexport default function nodeCanReceiveIndirectFocus(\n  focusState: FocusState,\n  node?: Node\n) {\n  if (!node) {\n    return false;\n  }\n\n  if (node.disabled || node.isExiting || node.trap) {\n    return false;\n  }\n\n  // This guards against a situation where a child is focusable, but\n  // it is not a leaf and has no focusable children.\n  const children = node.children || [];\n  if (children.length === 0) {\n    return true;\n  } else {\n    let someChildIsEnabled = false;\n\n    for (let i = 0; i < children.length; i++) {\n      const childId = children[i];\n      const childNode = focusState.nodes[childId];\n\n      const childCanReceiveFocus = nodeCanReceiveIndirectFocus(\n        focusState,\n        childNode\n      );\n\n      if (childCanReceiveFocus) {\n        someChildIsEnabled = true;\n        break;\n      }\n    }\n\n    if (!someChildIsEnabled) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","import clamp from './clamp';\nimport nodeCanReceiveIndirectFocus from './node-can-receive-indirect-focus';\nimport { FocusState, Id, NodeHierarchy, Orientation } from '../types';\n\ninterface GetParentsOptions {\n  focusState: FocusState;\n  nodeId: Id;\n  currentFocusHierarchy?: NodeHierarchy;\n}\n\nexport function getParents({\n  focusState,\n  nodeId,\n  currentFocusHierarchy = [],\n}: GetParentsOptions): NodeHierarchy {\n  const node = focusState.nodes[nodeId];\n\n  if (!node) {\n    return [];\n  }\n\n  const parentId = node.parentId;\n\n  if (parentId === null) {\n    return currentFocusHierarchy;\n  } else {\n    return getParents({\n      focusState,\n      nodeId: parentId,\n      currentFocusHierarchy: [parentId, ...currentFocusHierarchy],\n    });\n  }\n}\n\ninterface GetChildrenOptions extends GetParentsOptions {\n  orientation?: Orientation;\n  preferEnd?: boolean;\n  preferredChildren?: NodeHierarchy;\n}\n\nexport function getChildren({\n  focusState,\n  nodeId,\n  currentFocusHierarchy = [],\n  orientation,\n  preferEnd,\n  preferredChildren,\n}: GetChildrenOptions): Id[] {\n  const node = focusState.nodes[nodeId];\n\n  if (!node) {\n    return [];\n  }\n\n  const nodeChildren = node.children.filter((childId) => {\n    const node = focusState.nodes[childId];\n\n    return nodeCanReceiveIndirectFocus(focusState, node);\n  });\n\n  let nextPreferredChildren: NodeHierarchy = [];\n\n  if (nodeChildren.length === 0) {\n    return currentFocusHierarchy;\n  } else {\n    // When the node is a grid, and it has no preferred hierarchy, then we respect the defaultFocusRow/defaultFocusColumn\n    // attributes. Preferred children represent a focus trap.\n    if (\n      node.navigationStyle === 'grid' &&\n      (!preferredChildren || preferredChildren.length === 0)\n    ) {\n      const preferredRowIndex = node.defaultFocusRow ?? 0;\n      const rowIndex = clamp(preferredRowIndex, 0, node.children.length - 1);\n      const rowId = node.children[rowIndex];\n\n      const row = focusState.nodes[rowId];\n\n      if (!row || row.children.length === 0) {\n        return [...currentFocusHierarchy, rowId];\n      }\n\n      const preferredColumnIndex = node.defaultFocusColumn ?? 0;\n      const columnIndex = clamp(\n        preferredColumnIndex,\n        0,\n        row.children.length - 1\n      );\n      const columnId = row.children[columnIndex];\n\n      return getChildren({\n        focusState,\n        nodeId: columnId,\n        currentFocusHierarchy: [...currentFocusHierarchy, rowId, columnId],\n        preferredChildren: [],\n      });\n    }\n\n    let nextChildId = nodeChildren[0];\n    const numericdefaultFocusChild =\n      typeof node.defaultFocusChild === 'number' &&\n      Number.isFinite(node.defaultFocusChild);\n    const isValiddefaultFocusChild =\n      numericdefaultFocusChild || typeof node.defaultFocusChild === 'function';\n\n    // If the dev explicitly defined an explicit index, then we always use that.\n    if (isValiddefaultFocusChild && node.navigationStyle !== 'grid') {\n      let childIndex = 0;\n      if (numericdefaultFocusChild) {\n        // @ts-ignore\n        childIndex = node.defaultFocusChild;\n      } else {\n        // @ts-ignore\n        childIndex = node.defaultFocusChild();\n      }\n\n      if (typeof childIndex === 'number' && Number.isFinite(childIndex)) {\n        const maxChildIndex = Math.max(0, nodeChildren.length - 1);\n        childIndex = clamp(childIndex, 0, maxChildIndex);\n        nextChildId = nodeChildren[childIndex];\n      } else {\n        nextChildId = nodeChildren[0];\n      }\n    }\n\n    // Otherwise, there are situations where we choose a child other than the\n    // first.\n    else {\n      // `preferredChildren` exist currently when restoring a focus trap's hierarchy\n      if (preferredChildren && preferredChildren.length) {\n        const possibleId = preferredChildren[0];\n\n        if (focusState.nodes[possibleId]) {\n          nextChildId = possibleId;\n          nextPreferredChildren = preferredChildren.slice(1);\n        }\n      }\n\n      // This allows the focus index to restore to the index in\n      // the \"direction\" of motion. It's not incredibly common, but not so\n      // rare that it's an edge case.\n      if (orientation && orientation === node.orientation) {\n        // TODO: leaving this here in the event that I refactor the\n        // preferred column/row implementation above, even though\n        // it is currently redundant.\n        // @ts-ignore\n        const isGridNavigation = node.navigationStyle === 'grid';\n        const useLastNode = !isGridNavigation && preferEnd;\n\n        const lastIndex = Math.max(0, nodeChildren.length - 1);\n        const index = useLastNode ? lastIndex : 0;\n        nextChildId = nodeChildren[index];\n      }\n    }\n\n    return getChildren({\n      focusState,\n      nodeId: nextChildId,\n      currentFocusHierarchy: [...currentFocusHierarchy, nextChildId],\n      preferredChildren: nextPreferredChildren,\n    });\n  }\n}\n","import { getParents, getChildren } from '../utils/tree-navigation';\nimport { warning } from '../utils/warning';\nimport { FocusState, Id, Orientation, NodeHierarchy, Node } from '../types';\n\ninterface ComputeFocusHierarchyOptions {\n  focusState: FocusState;\n  assignFocusTo: Id | null | undefined;\n  orientation?: Orientation;\n  preferEnd?: boolean;\n}\n\ninterface GenerateFocusHierarchyFromIdOptions {\n  focusState: FocusState;\n  propagateFromId: Id;\n  orientation?: Orientation;\n  preferEnd?: boolean;\n}\n\nfunction generateFocusHierarchyFromId({\n  focusState,\n  propagateFromId,\n  orientation,\n  preferEnd,\n}: GenerateFocusHierarchyFromIdOptions): Id[] {\n  const node = focusState.nodes[propagateFromId] as unknown as Node;\n  let preferredChildren: NodeHierarchy = [];\n  if (node.trap) {\n    preferredChildren = node._focusTrapPreviousHierarchy;\n  }\n\n  return [\n    ...getParents({\n      focusState,\n      nodeId: propagateFromId,\n    }),\n    propagateFromId,\n    ...getChildren({\n      focusState,\n      nodeId: propagateFromId,\n      orientation,\n      preferEnd,\n      preferredChildren,\n    }),\n  ];\n}\n\nexport default function computeFocusHierarchy({\n  focusState,\n  assignFocusTo,\n  orientation,\n  preferEnd,\n}: ComputeFocusHierarchyOptions): Id[] {\n  const explicitlyAssignFocus =\n    typeof assignFocusTo === 'string' &&\n    assignFocusTo !== focusState.focusedNodeId;\n\n  if (explicitlyAssignFocus) {\n    // @ts-ignore\n    const assignedNode = focusState.nodes[assignFocusTo];\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (!assignedNode) {\n        warning(\n          'You attempted to explicitly focus a node that was not found in the focus tree. ' +\n            'This may represent a bug in your application. ' +\n            'You should ensure that a node that matches onMountAssignFocusTo is created and not disabled. ' +\n            'This onMountAssignFocusTo value has been ignored; focus will be computed automatically.',\n          'EXPLICIT_FOCUS_ERROR'\n        );\n      }\n    }\n\n    const focusHierarchy = generateFocusHierarchyFromId({\n      focusState,\n      // @ts-ignore\n      propagateFromId: assignFocusTo,\n      orientation,\n      preferEnd,\n    });\n\n    return focusHierarchy;\n  } else {\n    return generateFocusHierarchyFromId({\n      focusState,\n      propagateFromId: focusState.focusedNodeId,\n      orientation,\n      preferEnd,\n    });\n  }\n}\n","import { NodeHierarchy } from '../types';\n\ninterface GetFocusDiffOptions {\n  focusHierarchy: NodeHierarchy;\n  prevFocusHierarchy: NodeHierarchy;\n}\n\ninterface FocusDiff {\n  blur: NodeHierarchy;\n  focus: NodeHierarchy;\n  unchanged: NodeHierarchy;\n}\n\nexport default function getFocusDiff({\n  focusHierarchy = [],\n  prevFocusHierarchy = [],\n}: GetFocusDiffOptions): FocusDiff {\n  const largerIndex = Math.max(\n    focusHierarchy.length,\n    prevFocusHierarchy.length\n  );\n\n  let splitIndex = NaN;\n  for (let index = 0; index < largerIndex; index++) {\n    const prevId = prevFocusHierarchy[index];\n    const currentId = focusHierarchy[index];\n\n    if (prevId !== currentId) {\n      splitIndex = index;\n      break;\n    }\n  }\n\n  if (Number.isNaN(splitIndex)) {\n    return {\n      blur: [],\n      focus: [],\n      unchanged: prevFocusHierarchy,\n    };\n  }\n\n  const unchanged = prevFocusHierarchy.slice(0, splitIndex);\n  const blur = prevFocusHierarchy.slice(splitIndex);\n  const focus = focusHierarchy.slice(splitIndex);\n\n  return {\n    blur,\n    focus,\n    unchanged,\n  };\n}\n","import {\n  NodeMap,\n  Node,\n  Id,\n  FocusNode,\n  FocusState,\n  NodeHierarchy,\n} from '../types';\n\ninterface GetNodesFromFocusChangeOptions {\n  focusState: FocusState;\n  blurHierarchy: NodeHierarchy;\n  focusHierarchy: NodeHierarchy;\n  unchangedHierarchy: NodeHierarchy;\n}\n\nfunction getParentGrid(nodes: NodeMap, node: Node): FocusNode {\n  const parentId = node.parentId as Id;\n  const rowNode = nodes[parentId] as FocusNode;\n\n  const rowChildren = rowNode.children.filter((nodeId) => {\n    const node = nodes[nodeId];\n    return node && !node.disabled && !node.isExiting;\n  });\n\n  const columnIndex = rowChildren.indexOf(node.focusId);\n\n  const gridNodeId = rowNode.parentId as Id;\n  const gridNode = nodes[gridNodeId] as FocusNode;\n\n  const gridChildren = gridNode.children.filter((nodeId) => {\n    const node = nodes[nodeId];\n    return node && !node.disabled && !node.isExiting;\n  });\n\n  const rowIndex = gridChildren.indexOf(rowNode.focusId);\n\n  return {\n    ...gridNode,\n    _gridColumnIndex: columnIndex,\n    _gridRowIndex: rowIndex,\n  };\n}\n\nexport default function getNodesFromFocusChange({\n  focusState,\n  blurHierarchy,\n  focusHierarchy,\n  unchangedHierarchy,\n}: GetNodesFromFocusChangeOptions): NodeMap {\n  let result: NodeMap = {};\n\n  for (let i = 0; i < unchangedHierarchy.length; i++) {\n    const nodeId = unchangedHierarchy[i];\n    const node = focusState.nodes[nodeId];\n\n    if (!node) {\n      continue;\n    }\n\n    const isLastNode = i === unchangedHierarchy.length - 1;\n    const isFocusedLeaf = isLastNode && !focusHierarchy.length;\n\n    if (node.isFocusedLeaf !== isFocusedLeaf) {\n      result[nodeId] = {\n        ...node,\n        isFocusedLeaf,\n      };\n    }\n\n    if (isLastNode && focusHierarchy.length) {\n      const childId = focusHierarchy[0];\n      const childIndex = node.children.indexOf(childId);\n\n      result[nodeId] = {\n        ...node,\n        ...result[nodeId],\n        prevFocusedChildIndex: node.focusedChildIndex,\n        focusedChildIndex: childIndex,\n      };\n    }\n  }\n\n  for (let i = 0; i < blurHierarchy.length; i++) {\n    const nodeId = blurHierarchy[i];\n    const nodeToUpdate = focusState.nodes[nodeId] as Node;\n\n    // This guards against the situation where a node has been deleted.\n    if (!nodeToUpdate) {\n      continue;\n    }\n\n    result[nodeId] = {\n      ...nodeToUpdate,\n      isFocused: false,\n      isFocusedLeaf: false,\n      prevFocusedChildIndex: nodeToUpdate.focusedChildIndex,\n      focusedChildIndex: null,\n    };\n\n    // Upon navigating out of a grid, its \"saved\" state is reset.\n    if (nodeToUpdate.navigationStyle === 'grid') {\n      // @ts-ignore\n      result[nodeId]._gridColumnIndex = 0;\n      // @ts-ignore\n      result[nodeId]._gridRowIndex = 0;\n    }\n\n    if (nodeToUpdate.trap && !nodeToUpdate.forgetTrapFocusHierarchy) {\n      const childHierarchy = blurHierarchy.slice(i + 1);\n      // @ts-ignore\n      result[nodeId]._focusTrapPreviousHierarchy = childHierarchy;\n    }\n  }\n\n  for (let i = 0; i < focusHierarchy.length; i++) {\n    const nodeId = focusHierarchy[i];\n    const nodeToUpdate = focusState.nodes[nodeId] as Node;\n    const isLeafNode = i === focusHierarchy.length - 1;\n\n    result[nodeId] = {\n      ...nodeToUpdate,\n      isFocused: true,\n      isFocusedLeaf: i === focusHierarchy.length - 1,\n    };\n\n    if (nodeToUpdate.trap) {\n      // @ts-ignore\n      result[nodeId]._focusTrapPreviousHierarchy = [];\n    }\n\n    if (!isLeafNode) {\n      const childId = focusHierarchy[i + 1];\n      const childIndex = nodeToUpdate.children.indexOf(childId);\n\n      // @ts-ignore\n      result[nodeId].prevFocusedChildIndex = nodeToUpdate.focusedChildIndex;\n      // @ts-ignore\n      result[nodeId].focusedChildIndex = childIndex;\n    }\n\n    if (nodeToUpdate.nodeNavigationItem === 'grid-item') {\n      const updatedGridNode = getParentGrid(\n        {\n          ...focusState.nodes,\n          ...result,\n        },\n        result[nodeId] as Node\n      );\n\n      result[updatedGridNode.focusId] = updatedGridNode;\n    }\n  }\n\n  return result;\n}\n","import { Id, NodeMap, Node } from '../types';\n\ntype CallbackName = 'onBlurred' | 'onFocused';\n\nexport default function bubbleEvent({\n  nodeIds,\n  nodes,\n  callbackName,\n  arg,\n}: {\n  nodeIds: Id[];\n  nodes: NodeMap;\n  callbackName: CallbackName;\n  arg: {\n    focusNode: Node | undefined;\n    blurNode: Node | undefined;\n  };\n}) {\n  [...nodeIds].reverse().forEach((targetNodeId) => {\n    const node = nodes[targetNodeId];\n\n    if (!node) {\n      return;\n    }\n\n    const cb = node[callbackName];\n\n    if (typeof cb === 'function') {\n      const argToUse = {\n        ...arg,\n        currentNode: node,\n      };\n\n      cb(argToUse);\n    }\n  });\n}\n","import { NodeHierarchy, FocusState } from '../types';\nimport bubbleEvent from './bubble-focus-event';\n\nexport default function emitFocusStateEvents({\n  focus,\n  blur,\n  focusState,\n}: {\n  focus: NodeHierarchy;\n  blur: NodeHierarchy;\n  focusState: FocusState;\n}): void {\n  const blurNodeId = blur.slice(-1)[0];\n  const focusNodeId = focus.slice(-1)[0];\n\n  const blurNode =\n    typeof blurNodeId !== 'undefined'\n      ? focusState.nodes[blurNodeId]\n      : undefined;\n  const focusNode =\n    typeof focusNodeId !== 'undefined'\n      ? focusState.nodes[focusNodeId]\n      : undefined;\n\n  bubbleEvent({\n    nodeIds: blur,\n    nodes: focusState.nodes,\n    callbackName: 'onBlurred',\n    arg: {\n      blurNode,\n      focusNode,\n    },\n  });\n\n  bubbleEvent({\n    nodeIds: focus,\n    nodes: focusState.nodes,\n    callbackName: 'onFocused',\n    arg: {\n      blurNode,\n      focusNode,\n    },\n  });\n}\n","import computeFocusHierarchy from './compute-focus-hierarchy';\nimport getFocusDiff from './get-focus-diff';\nimport getNodesFromFocusChange from './get-nodes-from-focus-change';\nimport emitFocusStateEvents from './emit-focus-state-events';\nimport { FocusState, Id, Orientation } from '../types';\n\ninterface UpdateFocusOptions {\n  focusState: FocusState;\n  assignFocusTo: Id | null | undefined;\n  orientation?: Orientation;\n  preferEnd?: boolean;\n}\n\nexport default function updateFocus({\n  focusState,\n  assignFocusTo,\n  orientation,\n  preferEnd,\n}: UpdateFocusOptions): FocusState {\n  const newFocusHierarchy = computeFocusHierarchy({\n    focusState,\n    assignFocusTo,\n    orientation,\n    preferEnd,\n  });\n\n  const { blur, focus, unchanged } = getFocusDiff({\n    focusHierarchy: newFocusHierarchy,\n    prevFocusHierarchy: focusState.focusHierarchy,\n  });\n\n  const hierarchyHasChanged = blur.length || focus.length;\n\n  if (!hierarchyHasChanged) {\n    return focusState;\n  }\n\n  const newNodes = getNodesFromFocusChange({\n    focusState,\n    blurHierarchy: blur,\n    focusHierarchy: focus,\n    unchangedHierarchy: unchanged,\n  });\n\n  let focusedNodeId: Id;\n  if (focus.length) {\n    focusedNodeId = focus[focus.length - 1];\n  } else {\n    focusedNodeId = unchanged[unchanged.length - 1];\n  }\n\n  const newState: FocusState = {\n    _updatingFocusIsLocked: false,\n    nodes: {\n      ...focusState.nodes,\n      ...newNodes,\n    },\n    focusHierarchy: newFocusHierarchy,\n    focusedNodeId,\n    activeNodeId: focusState.activeNodeId,\n    interactionMode: focusState.interactionMode,\n    _hasPointerEventsEnabled: focusState._hasPointerEventsEnabled,\n  };\n\n  emitFocusStateEvents({\n    focus,\n    blur,\n    focusState: newState,\n  });\n\n  return newState;\n}\n","import nodeIdIsFocused from './node-id-is-focused';\nimport { warning } from './warning';\nimport updateFocus from '../update-focus/update-focus';\nimport { FocusState, Id, NodeMap, Node } from '../types';\n\nfunction recursivelyDeleteChildren(nodes: NodeMap, children: Id[]) {\n  children.forEach((childId) => {\n    const childNode = nodes[childId];\n    const childChildren = childNode ? childNode.children : null;\n\n    delete nodes[childId];\n\n    if (Array.isArray(childChildren)) {\n      recursivelyDeleteChildren(nodes, childChildren);\n    }\n  });\n}\n\nexport default function deleteNode({\n  focusState,\n  nodeId,\n}: {\n  focusState: FocusState;\n  nodeId: Id;\n}): FocusState | null {\n  const node = focusState.nodes[nodeId];\n\n  if (!node) {\n    return null;\n  }\n\n  if (nodeId === 'root') {\n    if (process.env.NODE_ENV !== 'production') {\n      warning(\n        'You attempted to delete the root node. ' +\n          'The root node of a focus tree cannot be deleted. ' +\n          'The focus tree has not been changed;',\n        'ATTEMPTED_TO_DELETE_ROOT'\n      );\n    }\n\n    return null;\n  }\n\n  const parentId = node.parentId;\n\n  // TODO: use type guards to type this away\n  if (!parentId) {\n    return null;\n  }\n\n  const parentNode = focusState.nodes[parentId] as Node;\n\n  let newParentChildren: Id[] = [];\n  if (parentNode.children.length > 1) {\n    newParentChildren = parentNode.children.filter((id) => id !== nodeId);\n  }\n\n  const newNodes: NodeMap = {\n    ...focusState.nodes,\n    [parentId]: {\n      ...parentNode,\n      children: newParentChildren,\n    },\n  };\n\n  delete newNodes[nodeId];\n\n  recursivelyDeleteChildren(newNodes, node.children);\n\n  let stateAfterDeletion = {\n    ...focusState,\n    nodes: newNodes,\n  };\n\n  const nodeWasFocused = nodeIdIsFocused(focusState.focusHierarchy, nodeId);\n\n  if (nodeWasFocused) {\n    stateAfterDeletion = updateFocus({\n      focusState: stateAfterDeletion,\n      assignFocusTo: parentId,\n    });\n  }\n\n  return stateAfterDeletion;\n}\n","import { Node, FocusState, Direction, Id } from '../../types';\nimport getIndex from '../../utils/get-index';\n\ninterface NavigateReturn {\n  newFocusedId: Id;\n  preferEnd: boolean;\n}\n\nexport default function navigateFromTargetNode({\n  focusState,\n  targetNode,\n  direction,\n}: {\n  focusState: FocusState;\n  targetNode: Node;\n  direction: Direction;\n}): NavigateReturn | null {\n  const parentId = targetNode.parentId as Id;\n  const parentNode = focusState.nodes[parentId];\n\n  if (!parentNode) {\n    return null;\n  }\n\n  const distance = direction === 'forward' ? 1 : -1;\n  const wrapping = parentNode.wrapping;\n  const preferEnd = direction === 'forward' ? false : true;\n\n  const targetNodeId = targetNode.focusId;\n\n  const allParentsChildren = parentNode.children || [];\n\n  const parentsChildren = allParentsChildren.filter((nodeId) => {\n    const node = focusState.nodes[nodeId];\n\n    if (!node) {\n      return false;\n    }\n\n    const isEnabled = !node.disabled;\n    const isExiting = node.isExiting;\n    const canReceiveFocusFromArrow = !node.trap;\n\n    return isEnabled && !isExiting && canReceiveFocusFromArrow;\n  });\n\n  const index = parentsChildren.indexOf(targetNodeId);\n\n  const newIndex = getIndex(parentsChildren.length, index + distance, wrapping);\n  const newFocusedId = parentsChildren[newIndex];\n  const newFocusedNode = focusState.nodes[newFocusedId];\n\n  // Disabled/exiting nodes cannot receive focus\n  if (!newFocusedNode || newFocusedNode.disabled || newFocusedNode.isExiting) {\n    return null;\n  }\n\n  return {\n    newFocusedId,\n    preferEnd,\n  };\n}\n","import navigateFromTargetNode from './navigate-from-target-node';\nimport { FocusState, Node, Orientation, Direction, Arrow } from '../../types';\nimport updateFocus from '../../update-focus/update-focus';\n\ninterface DefaultNavigationOptions {\n  focusState: FocusState;\n  orientation: Orientation;\n  direction: Direction;\n  targetNode: Node;\n  arrow: Arrow;\n}\n\nexport default function defaultNavigation({\n  focusState,\n  orientation,\n  targetNode,\n  direction,\n  arrow,\n}: DefaultNavigationOptions): FocusState | null {\n  const result = navigateFromTargetNode({\n    focusState,\n    targetNode,\n    direction,\n  });\n\n  if (!result) {\n    return null;\n  }\n\n  const newState = updateFocus({\n    focusState,\n    orientation,\n    assignFocusTo: result.newFocusedId,\n    preferEnd: result.preferEnd,\n  });\n\n  let parentNode: Node | null = null;\n  if (targetNode.parentId) {\n    parentNode = newState.nodes[targetNode.parentId] ?? null;\n  }\n\n  const stateChanged = newState !== focusState;\n\n  if (stateChanged && parentNode && typeof parentNode.onMove === 'function') {\n    const nextChildIndex = parentNode.focusedChildIndex as number;\n    const prevChildIndex = parentNode.prevFocusedChildIndex;\n\n    const currentFocusedNodeId = parentNode.children[nextChildIndex];\n    const currentFocusedNode = newState.nodes[currentFocusedNodeId] as Node;\n\n    const prevFocusedNodeId =\n      prevChildIndex === null ? null : parentNode.children[prevChildIndex];\n    const prevFocusedNode =\n      prevFocusedNodeId === null ? null : newState.nodes[prevFocusedNodeId];\n\n    parentNode.onMove({\n      orientation,\n      direction,\n      arrow,\n      node: parentNode,\n      prevChildIndex,\n      nextChildIndex,\n      prevChildNode: prevFocusedNode ?? null,\n      nextChildNode: currentFocusedNode,\n    });\n  }\n\n  return newState;\n}\n","import getIndex from './get-index';\nimport { Id, Orientation, Direction, Node, FocusState } from '../types';\n\ninterface GetGridFocusDataReturn {\n  targetFocusId: Id;\n  currentRowIndex: number;\n  currentColumnIndex: number;\n  newRowIndex: number;\n  newColumnIndex: number;\n}\n\nexport default function getGridFocusData({\n  focusState,\n  orientation,\n  direction,\n  gridNode,\n  rowNode,\n}: {\n  focusState: FocusState;\n  orientation: Orientation;\n  direction: Direction;\n  gridNode: Node;\n  rowNode: Node;\n}): GetGridFocusDataReturn | null {\n  const isVertical = orientation === 'vertical';\n  const isForward = direction === 'forward';\n\n  const currentRowIndex = gridNode._gridRowIndex ?? 0;\n  const currentColumnIndex = gridNode._gridColumnIndex ?? 0;\n\n  const actualRowIndex = Math.min(\n    currentRowIndex,\n    gridNode.children.length - 1\n  );\n\n  const actualColumnIndex = Math.min(\n    currentColumnIndex,\n    rowNode.children.length - 1\n  );\n\n  const distance = isForward ? 1 : -1;\n  const newRowIndex = isVertical\n    ? getIndex(\n        gridNode.children.length,\n        actualRowIndex + distance,\n        gridNode.wrapGridVertical\n      )\n    : actualRowIndex;\n  const newColumnIndex = !isVertical\n    ? getIndex(\n        rowNode.children.length,\n        actualColumnIndex + distance,\n        gridNode.wrapGridHorizontal\n      )\n    : currentColumnIndex;\n\n  const newRowNodeId = gridNode.children[newRowIndex];\n  const newRowNode = focusState.nodes[newRowNodeId];\n\n  if (!newRowNode) {\n    return null;\n  }\n\n  const itemIndex = Math.min(newColumnIndex, newRowNode.children.length - 1);\n  const newItemNodeId = newRowNode.children[itemIndex];\n\n  if (newItemNodeId === null) {\n    return null;\n  }\n\n  return {\n    targetFocusId: newItemNodeId,\n    currentRowIndex,\n    currentColumnIndex,\n    newRowIndex,\n    newColumnIndex,\n  };\n}\n","import { FocusState, Node, Orientation, Direction, Arrow } from '../../types';\nimport getGridFocusData from '../../utils/get-grid-focus-data';\nimport updateFocus from '../../update-focus/update-focus';\n\ninterface GridNavigationOptions {\n  focusState: FocusState;\n  orientation: Orientation;\n  direction: Direction;\n  focusedNode: Node;\n  gridNode: Node;\n  rowNode: Node;\n  arrow: Arrow;\n}\n\nexport default function gridNavigation({\n  focusState,\n  orientation,\n  gridNode,\n  rowNode,\n  direction,\n  arrow,\n}: GridNavigationOptions): FocusState | null {\n  const gridFocusData = getGridFocusData({\n    focusState,\n    orientation,\n    direction,\n    gridNode,\n    rowNode,\n  });\n\n  if (!gridFocusData) {\n    return null;\n  }\n\n  const {\n    targetFocusId,\n    currentRowIndex,\n    currentColumnIndex,\n    newRowIndex,\n    newColumnIndex,\n  } = gridFocusData;\n\n  const updatedFocusTree = updateFocus({\n    focusState,\n    orientation,\n    assignFocusTo: targetFocusId,\n    preferEnd: false,\n  });\n\n  // TODO: maybe add a check here to verify this is true?\n  const updatedGridNode = updatedFocusTree.nodes[gridNode.focusId] as Node;\n\n  const rowChanged = currentRowIndex !== newRowIndex;\n  const columnChanged = currentColumnIndex !== newColumnIndex;\n\n  const changeOccurred = rowChanged || columnChanged;\n  if (changeOccurred && typeof gridNode.onGridMove === 'function') {\n    gridNode.onGridMove({\n      orientation,\n      direction,\n      arrow,\n      gridNode,\n\n      prevRowIndex: currentRowIndex,\n      nextRowIndex: newRowIndex,\n\n      prevColumnIndex: currentColumnIndex,\n      nextColumnIndex: newColumnIndex,\n\n      // TODO: add these\n      // currentRowNode,\n      // nextRowNode,\n      // currentItemNode,\n      // nextItemNode\n    });\n  }\n\n  const newState = {\n    ...updatedFocusTree,\n    nodes: {\n      ...updatedFocusTree.nodes,\n      [gridNode.focusId]: {\n        ...updatedGridNode,\n        _gridColumnIndex: newColumnIndex,\n        _gridRowIndex: newRowIndex,\n      },\n    },\n  };\n\n  return newState;\n}\n","import { FocusState, Node, Id } from '../../types';\n\ninterface GetGridParent {\n  focusState: FocusState;\n  focusedNode: Node;\n}\n\ninterface GetGridParentReturn {\n  gridNode: Node;\n  rowNode: Node;\n}\n\nexport default function getGridParent({\n  focusState,\n  focusedNode,\n}: GetGridParent): GetGridParentReturn | null {\n  if (focusedNode.nodeNavigationItem === 'grid-item') {\n    const rowNodeId = focusedNode.parentId as Id;\n    const rowNode = focusState.nodes[rowNodeId];\n\n    if (!rowNode) {\n      return null;\n    }\n\n    const gridNodeId = rowNode.parentId as Id;\n    const gridNode = focusState.nodes[gridNodeId];\n\n    if (!gridNode) {\n      return null;\n    }\n\n    return {\n      gridNode,\n      rowNode,\n    };\n  } else if (focusedNode.nodeNavigationItem === 'grid-row') {\n    const gridNodeId = focusedNode.parentId as Id;\n    const gridNode = focusState.nodes[gridNodeId];\n\n    if (!gridNode) {\n      return null;\n    }\n\n    return {\n      gridNode,\n      rowNode: focusedNode,\n    };\n  }\n\n  return null;\n}\n","import getGridParent from './get-grid-parent';\nimport {\n  FocusState,\n  Node,\n  Orientation,\n  Direction,\n  GridStyle,\n} from '../../types';\n\nexport default function testForGrid({\n  focusState,\n  focusedNode,\n  orientation,\n  direction,\n}: {\n  focusState: FocusState;\n  focusedNode: Node;\n  orientation: Orientation;\n  direction: Direction;\n}): GridStyle | null {\n  const activeGridNodes = getGridParent({ focusState, focusedNode });\n\n  if (!activeGridNodes) {\n    return null;\n  }\n\n  const { gridNode, rowNode } = activeGridNodes;\n\n  const isVertical = orientation === 'vertical';\n  const isForward = direction === 'forward';\n\n  const currentRowIndex = gridNode._gridRowIndex ?? 0;\n  const currentColumnIndex = gridNode._gridColumnIndex ?? 0;\n\n  const actualRowIndex = Math.min(\n    currentRowIndex,\n    gridNode.children.length - 1\n  );\n\n  const actualColumnIndex = Math.min(\n    currentColumnIndex,\n    rowNode.children.length - 1\n  );\n\n  const isAtFirstRow = gridNode._gridRowIndex === 0;\n  const isAtLastRow = actualRowIndex === gridNode.children.length - 1;\n\n  const isAtFirstColumn = gridNode._gridColumnIndex === 0;\n  const isAtLastColumn = actualColumnIndex === rowNode.children.length - 1;\n\n  const movingBackwardVerticallyOnFirstRow =\n    isVertical && !isForward && isAtFirstRow;\n  const movingForwardVerticallyOnLastRow =\n    isVertical && isForward && isAtLastRow;\n\n  const movingBackwardHorizontallyOnFirstColumn =\n    !isVertical && !isForward && isAtFirstColumn;\n  const movingForwardHorizontallyOnLastColumn =\n    !isVertical && isForward && isAtLastColumn;\n\n  const wouldHandleVertical =\n    gridNode.wrapGridVertical ||\n    (!movingBackwardVerticallyOnFirstRow && !movingForwardVerticallyOnLastRow);\n  const wouldHandleHorizontal =\n    gridNode.wrapGridHorizontal ||\n    (!movingBackwardHorizontallyOnFirstColumn &&\n      !movingForwardHorizontallyOnLastColumn);\n\n  const movementIsWithinTheGrid =\n    (isVertical && wouldHandleVertical) ||\n    (!isVertical && wouldHandleHorizontal);\n\n  if (movementIsWithinTheGrid) {\n    return {\n      style: 'grid',\n      gridNode,\n      rowNode,\n    };\n  } else {\n    return null;\n  }\n}\n","import nodeCanReceiveIndirectFocus from '../../utils/node-can-receive-indirect-focus';\nimport { FocusState, Node, Orientation, Direction, Id } from '../../types';\n\nexport default function getDefaultNavTarget(\n  focusState: FocusState,\n  node: Node,\n  orientation: Orientation,\n  direction: Direction\n) {\n  const parentId = node.parentId as Id;\n  const parentNode = focusState.nodes[parentId];\n\n  if (!parentNode) {\n    return null;\n  }\n\n  if (parentNode.orientation === orientation) {\n    if (parentNode.wrapping) {\n      return node;\n    } else {\n      const unfilteredChildren = parentNode.children || [];\n\n      // We only consider children nodes that can receive focus via arrows\n      const parentsChildren = unfilteredChildren.filter((nodeId) => {\n        const node = focusState.nodes[nodeId];\n\n        if (!nodeCanReceiveIndirectFocus(focusState, node)) {\n          return false;\n        }\n\n        return true;\n      });\n\n      const index = parentsChildren.indexOf(node.focusId);\n\n      // This is true when pressing the \"forward\" key (right or down) and focus is\n      // on the *last* item in the list of children. For example:\n      // _ _ _ X\n      const movingForwardAndOnLastNode =\n        direction === 'forward' && index === parentsChildren.length - 1;\n\n      // This is true when pressing the \"backward\" key (left or up) and focus is\n      // on the *first* item in the list of children. For example:\n      // X _ _ _\n      const movingBackwardAndOnFirstNode =\n        direction === 'backward' && index === 0;\n\n      if (movingForwardAndOnLastNode || movingBackwardAndOnFirstNode) {\n        return null;\n      }\n\n      // If that is not true, then focus will remain within this parent and we return the node.\n      else {\n        return node;\n      }\n    }\n  } else {\n    return null;\n  }\n}\n","import testForGrid from './test-for-grid';\nimport getGridParent from './get-grid-parent';\nimport getDefaultNavTarget from './get-default-nav-target';\nimport {\n  FocusState,\n  Node,\n  Orientation,\n  Direction,\n  Arrow,\n  Id,\n  GridStyle,\n  DefaultStyle,\n} from '../../types';\n\ninterface DetermineNavigationStyleOptions {\n  focusState: FocusState;\n  orientation: Orientation;\n  direction: Direction;\n  focusedNode: Node;\n  arrow: Arrow;\n}\n\ninterface ProcessNodeOptions {\n  focusState: FocusState;\n  orientation: Orientation;\n  direction: Direction;\n  node: Node;\n  arrow: Arrow;\n}\n\nfunction processNode({\n  arrow,\n  focusState,\n  node,\n  direction,\n  orientation,\n}: ProcessNodeOptions): GridStyle | DefaultStyle | null {\n  // This is the operative line of code that makes focus traps function.\n  // When a trap node is encountered, we return null, which signifies\n  // no navigation at all.\n  // Without this check, this function start traversing up the tree outside of the focus\n  // trap, which could potentially cause focus to leave the trap.\n  if (node.trap) {\n    return null;\n  }\n\n  const parentId = node.parentId as Id;\n  const parentNode = focusState.nodes[parentId];\n\n  if (!parentNode) {\n    return null;\n  }\n\n  const isGridNode =\n    node.nodeNavigationItem === 'grid-item' ||\n    node.nodeNavigationItem === 'grid-row';\n\n  if (isGridNode) {\n    const gridHandle = testForGrid({\n      focusState,\n      focusedNode: node,\n      direction,\n      orientation,\n    });\n\n    if (!gridHandle) {\n      const activeGridNodes = getGridParent({ focusState, focusedNode: node });\n\n      if (activeGridNodes) {\n        return processNode({\n          arrow,\n          focusState,\n          node: activeGridNodes.gridNode,\n          direction,\n          orientation,\n        });\n      }\n    } else {\n      return gridHandle;\n    }\n  }\n\n  const defaultNavigationTargetNode = getDefaultNavTarget(\n    focusState,\n    node,\n    orientation,\n    direction\n  );\n\n  if (defaultNavigationTargetNode) {\n    return {\n      style: 'default',\n      targetNode: defaultNavigationTargetNode,\n    };\n  }\n\n  return processNode({\n    arrow,\n    focusState,\n    node: parentNode,\n    direction,\n    orientation,\n  });\n}\n\nexport default function determineNavigationStyle({\n  arrow,\n  focusState,\n  focusedNode,\n  direction,\n  orientation,\n}: DetermineNavigationStyleOptions) {\n  const result = processNode({\n    arrow,\n    focusState,\n    node: focusedNode,\n    direction,\n    orientation,\n  });\n\n  return result;\n}\n","import defaultNavigation from './default-navigation/default-navigation';\nimport gridNavigation from './grid-navigation/grid-navigation';\nimport determineNavigationStyle from './determine-navigation-style/determine-navigation-style';\nimport { FocusState, Arrow, Orientation, Direction } from '../types';\n\ninterface HandleArrowOptions {\n  focusState: FocusState;\n  arrow: Arrow;\n}\n\nexport default function handleArrow({\n  focusState,\n  arrow,\n}: HandleArrowOptions): FocusState | null {\n  const orientation: Orientation =\n    arrow === 'right' || arrow === 'left' ? 'horizontal' : 'vertical';\n  const direction: Direction =\n    arrow === 'down' || arrow === 'right' ? 'forward' : 'backward';\n\n  const focusedNode = focusState.nodes[focusState.focusedNodeId];\n\n  if (!focusedNode) {\n    return null;\n  }\n\n  const navigationStyle = determineNavigationStyle({\n    arrow,\n    focusState,\n    focusedNode,\n    direction,\n    orientation,\n  });\n\n  if (!navigationStyle) {\n    return null;\n  } else if (navigationStyle.style === 'default') {\n    return defaultNavigation({\n      arrow,\n      focusState,\n      targetNode: navigationStyle.targetNode,\n      direction,\n      orientation,\n    });\n  } else if (navigationStyle.style === 'grid') {\n    return gridNavigation({\n      arrow,\n      focusState,\n      focusedNode,\n      gridNode: navigationStyle.gridNode,\n      rowNode: navigationStyle.rowNode,\n      direction,\n      orientation,\n    });\n  }\n\n  return null;\n}\n","import { FocusState, Node, NodeMap, Id } from '../types';\nimport nodeCanReceiveIndirectFocus from './node-can-receive-indirect-focus';\n\nfunction validateNode(node: Node, nodes: NodeMap, focusState: FocusState) {\n  const enabledNodeChildren = node.children.filter((childId) => {\n    const node = nodes[childId];\n    return nodeCanReceiveIndirectFocus(focusState, node);\n  });\n\n  if (enabledNodeChildren.length > 0 && node.isFocusedLeaf) {\n    console.error(\n      '[[ Focus State Internal Error ]]: A focus node has isFocusedLeaf: true, yet it has enabled children.',\n      node,\n      nodes\n    );\n  } else if (\n    enabledNodeChildren.length === 0 &&\n    node.isFocused &&\n    !node.isFocusedLeaf\n  ) {\n    console.error(\n      '[[ Focus State Internal Error ]]: A node is focused, has no enabled children, but does not have isFocusedLeaf: true.',\n      node,\n      nodes\n    );\n  }\n\n  if (node.children.length > 1) {\n    node.children.forEach((childNodeId) => {\n      if (!nodes[childNodeId]) {\n        console.error(\n          '[[ Focus State Internal Error ]]: A node has a child that does not exist.',\n          node,\n          nodes\n        );\n      }\n    });\n  }\n\n  if (node.isRoot && node.parentId !== null) {\n    console.error(\n      '[[ Focus State Internal Error ]]: The root node has a parent.',\n      node,\n      nodes\n    );\n  } else if (!node.isRoot) {\n    const parentId = node.parentId as Id;\n\n    if (!nodes[parentId]) {\n      console.error(\n        '[[ Focus State Internal Error ]]: A node has a parent that does not exist.',\n        node,\n        nodes\n      );\n    }\n  }\n}\n\nexport default function enforceStateStructure(focusState: FocusState) {\n  const focusedNodeId = focusState.focusedNodeId;\n\n  if (typeof focusedNodeId !== 'string') {\n    console.error(\n      '[[ Focus State Internal Error ]]: The focused node ID is not a string.',\n      focusState\n    );\n  } else {\n    if (!focusState.nodes[focusedNodeId]) {\n      console.error(\n        '[[ Focus State Internal Error ]]: A focused node is set that does not exist in the node tree.',\n        focusState\n      );\n    }\n  }\n\n  Object.values(focusState.nodes).forEach((node) => {\n    if (node) {\n      validateNode(node, focusState.nodes, focusState);\n    }\n  });\n}\n","import { Id, NodeMap, NodeUpdate } from '../types';\n\nexport default function recursivelyUpdateChildren(\n  nodes: NodeMap,\n  children: Id[],\n  update: NodeUpdate\n): NodeMap {\n  let newNodes: NodeMap = {};\n\n  children.forEach(childId => {\n    const childNode = nodes[childId];\n\n    if (!childNode) {\n      return;\n    }\n\n    const childChildren = childNode ? childNode.children : null;\n\n    newNodes[childNode.focusId] = {\n      ...childNode,\n      ...update,\n    };\n\n    if (Array.isArray(childChildren)) {\n      const updatedChildrenNodes = recursivelyUpdateChildren(\n        nodes,\n        childChildren,\n        update\n      );\n      newNodes = {\n        ...newNodes,\n        ...updatedChildrenNodes,\n      };\n    }\n  });\n\n  return newNodes;\n}\n","import { FocusStore, Node, Arrow, LRUDKey, LRUDFocusEvents } from '../types';\n\ntype FocusCallbackNames = keyof LRUDFocusEvents;\ntype PreventDefault = () => void;\ntype StopPropagation = () => void;\n\nfunction executeFunction(\n  node: Node,\n  fn: FocusCallbackNames,\n  {\n    isArrow,\n    key,\n    targetNode,\n    preventDefault,\n    stopPropagation,\n  }: {\n    isArrow: boolean;\n    key: LRUDKey;\n    targetNode: Node;\n    preventDefault: PreventDefault;\n    stopPropagation: StopPropagation;\n  }\n) {\n  const cb = node[fn];\n\n  if (typeof cb === 'function') {\n    const arg = {\n      isArrow,\n      key,\n      node,\n      stopPropagation,\n      preventDefault,\n      targetNode,\n    };\n    cb(arg);\n  }\n}\n\nexport default function bubbleKey(focusTree: FocusStore, key: LRUDKey) {\n  const state = focusTree.getState();\n  const { focusHierarchy } = state;\n\n  const isArrow =\n    key === 'up' || key === 'down' || key === 'right' || key === 'left';\n  const isSelect = key === 'select';\n  const isBack = key === 'back';\n\n  let defaultPrevented = false;\n  let propagationStopped = false;\n\n  const reverseFocusHierarchy = focusHierarchy.slice().reverse();\n  if (reverseFocusHierarchy.length) {\n    // @ts-ignore\n    function preventDefault() {\n      defaultPrevented = true;\n    }\n\n    // @ts-ignore\n    function stopPropagation() {\n      propagationStopped = true;\n    }\n\n    const targetNodeId = reverseFocusHierarchy[0];\n\n    // This is the equivalent of event.target within DOM events.\n    const targetNode: Node = state.nodes[targetNodeId] as Node;\n\n    reverseFocusHierarchy.forEach((focusedNodeId) => {\n      if (propagationStopped) {\n        return;\n      }\n\n      const node = state.nodes[focusedNodeId];\n\n      if (!node) {\n        return;\n      }\n\n      executeFunction(node, 'onKey', {\n        isArrow,\n        key,\n        targetNode,\n        preventDefault,\n        stopPropagation,\n      });\n\n      if (isArrow) {\n        executeFunction(node, 'onArrow', {\n          isArrow,\n          key,\n          targetNode,\n          preventDefault,\n          stopPropagation,\n        });\n      }\n\n      if (key === 'left') {\n        executeFunction(node, 'onLeft', {\n          isArrow,\n          key,\n          targetNode,\n          preventDefault,\n          stopPropagation,\n        });\n      }\n\n      if (key === 'right') {\n        executeFunction(node, 'onRight', {\n          isArrow,\n          key,\n          targetNode,\n          preventDefault,\n          stopPropagation,\n        });\n      }\n\n      if (key === 'up') {\n        executeFunction(node, 'onUp', {\n          isArrow,\n          key,\n          targetNode,\n          preventDefault,\n          stopPropagation,\n        });\n      }\n\n      if (key === 'down') {\n        executeFunction(node, 'onDown', {\n          isArrow,\n          key,\n          targetNode,\n          preventDefault,\n          stopPropagation,\n        });\n      }\n\n      if (isSelect) {\n        executeFunction(node, 'onSelected', {\n          isArrow,\n          key,\n          targetNode,\n          stopPropagation,\n          preventDefault: () => {},\n        });\n      }\n\n      if (isBack) {\n        executeFunction(node, 'onBack', {\n          isArrow,\n          key,\n          targetNode,\n          stopPropagation,\n          preventDefault: () => {},\n        });\n      }\n    });\n  }\n\n  if (isArrow && !defaultPrevented) {\n    /* This cast is, for some reason, required for TSDX */\n    focusTree.handleArrow(key as Arrow);\n  } else if (isSelect && !defaultPrevented) {\n    focusTree.handleSelect();\n  }\n}\n","import createNode from './utils/create-node';\nimport deleteNodeUtil from './utils/delete-node';\nimport updateFocus from './update-focus/update-focus';\nimport handleArrowUtil from './handle-arrow/handle-arrow';\nimport enforceStateStructure from './utils/enforce-state-structure';\nimport recursivelyUpdateChildren from './utils/recursively-update-node';\nimport bubbleKey from './utils/bubble-key-input';\nimport { warning } from './utils/warning';\nimport {\n  FocusState,\n  Orientation,\n  Node,\n  Id,\n  NavigationStyle,\n  Arrow,\n  FocusStore,\n  NodeUpdate,\n  Listener,\n  NodeDefinition,\n  InteractionMode,\n  LRUDKey,\n} from './types';\n\ninterface CreateFocusStoreOptions {\n  orientation?: Orientation;\n  wrapping?: boolean;\n  navigationStyle?: NavigationStyle;\n  pointerEvents?: boolean;\n}\n\n// When these props of a node change, then the store\n// will alert subscribers.\nconst dynamicNodeProps = [\n  'defaultFocusChild',\n  'disabled',\n  'isExiting',\n  'defaultFocusColumn',\n  'defaultFocusRow',\n  'wrapping',\n  'trap',\n  'forgetTrapFocusHierarchy',\n];\n\nexport default function createFocusStore({\n  orientation = 'horizontal',\n  wrapping = false,\n  pointerEvents = false,\n}: CreateFocusStoreOptions = {}): FocusStore {\n  let currentState: FocusState = {\n    focusedNodeId: 'root',\n    activeNodeId: null,\n    focusHierarchy: ['root'],\n\n    // TODO: should the interaction state values be moved out of the state and placed\n    // on the store directly?\n    interactionMode: 'lrud',\n    _hasPointerEventsEnabled: pointerEvents,\n\n    _updatingFocusIsLocked: false,\n    nodes: {\n      root: {\n        // Note: this a \"fake\" React ref in that React isn't ensuring\n        // that it stays constant.\n        elRef: {\n          current: null,\n        },\n        focusId: 'root',\n        isRoot: true,\n        parentId: null,\n        active: false,\n        isExiting: false,\n        isFocused: true,\n        isFocusedLeaf: true,\n        trap: false,\n        disabled: false,\n        defaultFocusColumn: 0,\n        defaultFocusRow: 0,\n        orientation,\n        wrapping,\n        navigationStyle: 'first-child',\n        nodeNavigationItem: 'default',\n        forgetTrapFocusHierarchy: true,\n        children: [],\n        focusedChildIndex: null,\n        prevFocusedChildIndex: null,\n        _gridColumnIndex: null,\n        _gridRowIndex: null,\n        wrapGridVertical: false,\n        wrapGridHorizontal: false,\n        _focusTrapPreviousHierarchy: [],\n      },\n    },\n  };\n\n  let listeners: Listener[] = [];\n  function subscribe(listener: Listener) {\n    listeners.push(listener);\n    let subscribed = true;\n\n    return function unsubscribe() {\n      if (!subscribed) {\n        return;\n      }\n\n      subscribed = false;\n\n      const index = listeners.indexOf(listener);\n      listeners.splice(index, 1);\n    };\n  }\n\n  function onUpdate() {\n    for (let i = 0; i < listeners.length; i++) {\n      const listener = listeners[i];\n      listener();\n    }\n  }\n\n  function createNodes(\n    nodeHierarchy: Node[],\n    nodeDefinitionHierarchy: NodeDefinition[]\n  ) {\n    const { nodes, assignFocusTo, shouldLockFocus } = createNode({\n      focusState: currentState,\n      nodeHierarchy,\n      nodeDefinitionHierarchy,\n    });\n\n    if (shouldLockFocus) {\n      currentState._updatingFocusIsLocked = shouldLockFocus;\n    }\n\n    const hasNodesToUpdate = Boolean(nodes);\n    const isUnlockingFocus =\n      !shouldLockFocus && currentState._updatingFocusIsLocked;\n\n    if (hasNodesToUpdate || isUnlockingFocus) {\n      let possibleNewState = {\n        ...currentState,\n        nodes: {\n          ...currentState.nodes,\n          ...nodes,\n        },\n      };\n\n      // When the focus is locked, we \"silently\" update the state. We may be adding new nodes and so on,\n      // but the tree's focus state is not being updated.\n      if (shouldLockFocus) {\n        currentState = {\n          ...possibleNewState,\n          _updatingFocusIsLocked: true,\n        };\n      } else {\n        const nodeHierarchyIds = nodeHierarchy.map((node) => node.focusId);\n\n        const focusedItemIndex = nodeHierarchyIds.indexOf(\n          currentState.focusedNodeId\n        );\n\n        const assigningFocusOnMount = nodeDefinitionHierarchy.findIndex(\n          (v) => v.onMountAssignFocusTo\n        );\n\n        let updatedFocusState = possibleNewState;\n        if (focusedItemIndex > -1 || assigningFocusOnMount > -1) {\n          updatedFocusState = updateFocus({\n            focusState: possibleNewState,\n            assignFocusTo,\n          });\n        }\n\n        if (updatedFocusState !== currentState) {\n          currentState = updatedFocusState;\n          onUpdate();\n        }\n      }\n    }\n  }\n\n  function deleteNode(nodeId: Id): void {\n    const newState = deleteNodeUtil({\n      focusState: currentState,\n      nodeId,\n    });\n\n    if (newState && newState !== currentState) {\n      currentState = newState;\n      onUpdate();\n    }\n  }\n\n  function setFocus(nodeId: Id): void {\n    const currentNode = currentState.nodes[nodeId];\n\n    if (!currentNode) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (typeof nodeId !== 'string') {\n          warning(\n            `You called setFocus with a node ID that is not a string. The node ID that you passed was: ${nodeId}. All node IDs are strings.`,\n            'NODE_ID_NOT_STRING_TO_SET_FOCUS'\n          );\n        } else {\n          warning(\n            'You attempted to set focus to a node that does not exist in the focus tree.',\n            'NODE_DOES_NOT_EXIST'\n          );\n        }\n      }\n\n      return;\n    } else if (currentNode.disabled) {\n      return;\n    } else if (currentNode.isExiting) {\n      if (process.env.NODE_ENV !== 'production') {\n        warning(\n          'You attempted to set focus to a node that is exiting. This has no effect, but it may represent a memory leak in your application.',\n          'FOCUS_SET_TO_EXITING_NODE'\n        );\n      }\n      return;\n    }\n\n    const updatedFocusState = updateFocus({\n      focusState: currentState,\n      assignFocusTo: nodeId,\n    });\n\n    if (updatedFocusState !== currentState) {\n      currentState = updatedFocusState;\n\n      onUpdate();\n    }\n  }\n\n  function getState(): FocusState {\n    return currentState;\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    subscribe(() => {\n      enforceStateStructure(currentState);\n    });\n  }\n\n  function setInteractionMode(newMode: InteractionMode) {\n    if (newMode === currentState.interactionMode) {\n      return;\n    }\n\n    const newFocusState: FocusState = {\n      ...currentState,\n      interactionMode: newMode,\n    };\n\n    currentState = newFocusState;\n  }\n\n  function updateNode(nodeId: Id, update: NodeUpdate) {\n    const currentNode = currentState.nodes[nodeId];\n\n    if (!currentNode) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (update.disabled) {\n          warning(\n            'You attempted to disable a node that does not exist in the focus tree. ' +\n              'This has no effect, but it may represent an error in your code.',\n            'DISABLE_NODE_THAT_DOES_NOT_EXIST'\n          );\n        }\n\n        if (update.isExiting) {\n          warning(\n            'You attempted to exit a node that does not exist in the focus tree. ' +\n              'This has no effect, but it may represent an error in your code.',\n            'EXIT_NODE_THAT_DOES_NOT_EXIST'\n          );\n        }\n      }\n\n      return;\n    }\n\n    if (nodeId === 'root') {\n      if (process.env.NODE_ENV !== 'production') {\n        if (update.disabled) {\n          warning(\n            'You attempted to disable the root node. ' +\n              'The root node of a focus tree cannot be disabled. ' +\n              'This has no effect, but it may represent an error in your code.',\n            'DISABLE_ROOT_NODE'\n          );\n        }\n\n        if (update.isExiting) {\n          warning(\n            'You attempted to exit the root node. ' +\n              'The root node of a focus tree cannot be exited. ' +\n              'This has no effect, but it may represent an error in your code.',\n            'EXIT_ROOT_NODE'\n          );\n        }\n      }\n      return;\n    }\n\n    const updateHasDisabled = update.disabled !== undefined;\n    const updateHasExiting = update.isExiting !== undefined;\n\n    if (updateHasDisabled) {\n      update.disabled = Boolean(update.disabled);\n    }\n\n    if (updateHasExiting) {\n      update.isExiting = Boolean(update.isExiting);\n    }\n\n    const nodeChanged = dynamicNodeProps.some((prop) => {\n      // @ts-ignore\n      const updateValue = update[prop];\n      const updateValueExists = updateValue !== undefined;\n\n      // @ts-ignore\n      return updateValueExists && currentNode[prop] !== update[prop];\n    });\n\n    if (update && nodeChanged) {\n      const newNode: Node = {\n        ...currentNode,\n        disabled: update.disabled ?? currentNode.disabled,\n        isExiting: update.isExiting ?? currentNode.isExiting,\n        defaultFocusColumn:\n          update.defaultFocusColumn ?? currentNode.defaultFocusColumn,\n        defaultFocusRow: update.defaultFocusRow ?? currentNode.defaultFocusRow,\n        wrapping: update.wrapping ?? currentNode.wrapping,\n        trap: update.trap ?? currentNode.trap,\n        forgetTrapFocusHierarchy:\n          update.forgetTrapFocusHierarchy ??\n          currentNode.forgetTrapFocusHierarchy,\n        defaultFocusChild:\n          update.defaultFocusChild ?? currentNode.defaultFocusChild,\n      };\n\n      let updatedChildren = {};\n\n      if (updateHasExiting || updateHasDisabled) {\n        let recursiveUpdate: NodeUpdate = {};\n        if (updateHasDisabled) {\n          recursiveUpdate.disabled = update.disabled;\n        }\n        if (updateHasExiting) {\n          recursiveUpdate.isExiting = update.isExiting;\n        }\n\n        updatedChildren = recursivelyUpdateChildren(\n          currentState.nodes,\n          newNode.children,\n          // Note: we don't pass the full update as the other attributes (trap, wrapping, etc)\n          // only affect the parent, whereas these specific values affect the children.\n          recursiveUpdate\n        );\n      }\n\n      const nodeWasFocused = currentState.focusHierarchy.find(\n        (v) => v === nodeId\n      );\n\n      let updatedState = {\n        ...currentState,\n        nodes: {\n          ...currentState.nodes,\n          ...updatedChildren,\n          [nodeId]: newNode,\n        },\n      };\n\n      // Only do this if the update actually updated these\n      if (nodeWasFocused && (updateHasDisabled || updateHasExiting)) {\n        const parentId = newNode.parentId as Id;\n\n        updatedState = updateFocus({\n          focusState: updatedState,\n          assignFocusTo: parentId,\n        });\n      }\n\n      currentState = updatedState;\n      onUpdate();\n    }\n  }\n\n  function handleArrow(arrow: Arrow) {\n    const newState = handleArrowUtil({\n      focusState: currentState,\n      arrow,\n    });\n\n    if (!newState) {\n      return;\n    }\n\n    if (newState.interactionMode !== 'lrud') {\n      newState.interactionMode = 'lrud';\n    }\n\n    if (newState !== currentState) {\n      currentState = newState;\n      onUpdate();\n    }\n  }\n\n  function handleSelect(focusId?: string) {\n    const leafNodeId =\n      typeof focusId === 'string'\n        ? focusId\n        : currentState.focusHierarchy[currentState.focusHierarchy.length - 1];\n    const leafNode = currentState.nodes[leafNodeId];\n\n    if (leafNodeId === currentState.activeNodeId) {\n      return;\n    }\n\n    if (!leafNode) {\n      return;\n    }\n\n    const newNode: Node = {\n      ...leafNode,\n      active: true,\n    };\n\n    const newNodes = {\n      [leafNodeId]: newNode,\n    };\n\n    if (currentState.activeNodeId) {\n      const previousActiveNode = currentState.nodes[currentState.activeNodeId];\n\n      if (previousActiveNode) {\n        newNodes[currentState.activeNodeId] = {\n          ...previousActiveNode,\n          active: false,\n        };\n      }\n    }\n\n    const updatedState = {\n      ...currentState,\n      activeNodeId: leafNodeId,\n      nodes: {\n        ...currentState.nodes,\n        ...newNodes,\n      },\n    };\n\n    currentState = updatedState;\n    onUpdate();\n  }\n\n  // This boolean tracks whether or not we have registered our pointer listeners.\n  // This ensures that we never register those listeners more than once.\n  let isListeningToPointerEvents = false;\n\n  // This allows a user to dynamically enable/disable pointer events.\n  function configurePointerEvents(enablePointerEvents: boolean) {\n    const existingState = currentState;\n\n    currentState = {\n      ...existingState,\n      _hasPointerEventsEnabled: enablePointerEvents,\n    };\n\n    if (enablePointerEvents && !isListeningToPointerEvents) {\n      addPointerListeners();\n    }\n\n    if (!enablePointerEvents) {\n      removePointerListeners();\n    }\n  }\n\n  let handlingPointerEvent = false;\n  function onPointerEvent() {\n    if (handlingPointerEvent) {\n      return;\n    }\n\n    handlingPointerEvent = true;\n    requestAnimationFrame(() => {\n      setInteractionMode('pointer');\n      handlingPointerEvent = false;\n    });\n  }\n\n  function addPointerListeners() {\n    isListeningToPointerEvents = true;\n    window.addEventListener('mousemove', onPointerEvent);\n    window.addEventListener('mousedown', onPointerEvent);\n  }\n\n  function removePointerListeners() {\n    isListeningToPointerEvents = false;\n    window.removeEventListener('mousemove', onPointerEvent);\n    window.removeEventListener('mousedown', onPointerEvent);\n  }\n\n  function destroy() {\n    removePointerListeners();\n  }\n\n  if (pointerEvents) {\n    addPointerListeners();\n  }\n\n  function internalProcessKey(key: LRUDKey) {\n    bubbleKey(_focusStore, key);\n  }\n\n  const _focusStore: FocusStore = {\n    subscribe,\n    getState,\n    createNodes,\n    deleteNode,\n    setFocus,\n    updateNode,\n    handleArrow,\n    handleSelect,\n    configurePointerEvents,\n    destroy,\n    processKey: {\n      select: () => internalProcessKey('select'),\n      back: () => internalProcessKey('back'),\n      down: () => internalProcessKey('down'),\n      left: () => internalProcessKey('left'),\n      right: () => internalProcessKey('right'),\n      up: () => internalProcessKey('up'),\n    },\n  };\n\n  return _focusStore;\n}\n","interface Options {\n  leading?: boolean;\n  trailing?: boolean;\n}\n\nexport default function throttle(\n  func: (e: any) => void,\n  wait: number,\n  options?: Options\n) {\n  // @ts-ignore\n  var context, args, result;\n  // @ts-ignore\n  var timeout = null;\n  var previous = 0;\n  if (!options) options = {};\n\n  var later = function () {\n    // @ts-ignore\n    previous = options.leading === false ? 0 : Date.now();\n    timeout = null;\n    // @ts-ignore\n    result = func.apply(context, args);\n    if (!timeout) context = args = null;\n  };\n\n  return function () {\n    var now = Date.now();\n    // @ts-ignore\n    if (!previous && options.leading === false) previous = now;\n    var remaining = wait - (now - previous);\n    // @ts-ignore\n    context = this;\n    args = arguments;\n    if (remaining <= 0 || remaining > wait) {\n      // @ts-ignore\n      if (timeout) {\n        // @ts-ignore\n        clearTimeout(timeout);\n        timeout = null;\n      }\n      previous = now;\n      // @ts-ignore\n      result = func.apply(context, args);\n      // @ts-ignore\n      if (!timeout) context = args = null;\n      // @ts-ignore\n    } else if (!timeout && options.trailing !== false) {\n      timeout = setTimeout(later, remaining);\n    }\n    // @ts-ignore\n    return result;\n  };\n}\n","// This maps a Key string, returned from an event, to a handler name.\nexport default {\n  ArrowUp: 'up',\n  ArrowDown: 'down',\n  ArrowLeft: 'left',\n  ArrowRight: 'right',\n  Enter: 'select',\n  Escape: 'back',\n};\n","import throttle from './throttle';\nimport keyToBindingMap from './key-to-binding-map';\nimport { FocusStore } from '../types';\n\nexport default function focusLrud(focusStore: FocusStore) {\n  const lrudMapping = {\n    up() {\n      focusStore.processKey.up();\n    },\n\n    down() {\n      focusStore.processKey.down();\n    },\n\n    left() {\n      focusStore.processKey.left();\n    },\n\n    right() {\n      focusStore.processKey.right();\n    },\n\n    select() {\n      focusStore.processKey.select();\n    },\n\n    back() {\n      focusStore.processKey.back();\n    },\n  };\n\n  \n  function subscribe(throttleDelay:number) {\n    const keydownHandler = throttle(\n      function (e: KeyboardEvent) {\n        // @ts-ignore\n        const bindingName = keyToBindingMap[e.key];\n        // @ts-ignore\n        const binding = lrudMapping[bindingName];\n  \n        if (typeof binding === 'function') {\n          e.preventDefault();\n          e.stopPropagation();\n  \n          binding();\n        }\n      },\n      // TODO: support throttling. Ideally on a per-node basis.\n      throttleDelay,\n      {\n        trailing: false,\n      }\n    );\n    window.addEventListener('keydown', keydownHandler);\n\n    function unsubscribe() {\n      window.removeEventListener('keydown', keydownHandler);\n    }\n\n    return unsubscribe\n  }\n\n\n  return {\n    subscribe,\n  };\n}\n","import React, { useState, useEffect, useRef } from 'react';\nimport createFocusStore from './focus-store';\nimport lrudInput from './lrud-input/focus-lrud';\nimport { ProviderValue, RootFocusNode, Orientation } from './types';\nimport { warning } from './utils/warning';\n\nconst FocusContext = React.createContext<null | ProviderValue>(null);\n\nfunction FocusRoot({\n  orientation,\n  wrapping,\n  children,\n  pointerEvents,\n  throttle = 0\n}: {\n  children?: React.ReactNode;\n  orientation?: Orientation;\n  wrapping?: boolean;\n  pointerEvents?: boolean;\n  throttle?:number\n}) {\n  const rootElRef = useRef(null);\n  const [providerValue] = useState<ProviderValue>(() => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (\n        orientation !== undefined &&\n        orientation !== 'vertical' &&\n        orientation !== 'horizontal'\n      ) {\n        warning(\n          'An invalid orientation was passed to the FocusRoot. The orientation must either be \"vertical\" or \"horizontal.\"',\n          'INVALID_ROOT_ORIENTATION'\n        );\n      }\n    }\n\n    const store = createFocusStore({\n      orientation,\n      wrapping,\n      pointerEvents,\n    });\n\n    return {\n      store,\n      focusDefinitionHierarchy: [\n        {\n          elRef: rootElRef,\n          focusId: 'root',\n        },\n      ],\n      focusNodesHierarchy: [store.getState().nodes.root as RootFocusNode],\n    };\n  });\n\n  useEffect(() => {\n    const lrud = lrudInput(providerValue.store);\n    const unsubscribe = lrud.subscribe(throttle);\n    return () => {\n      unsubscribe();\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  return (\n    <FocusContext.Provider value={providerValue}>\n      {children}\n    </FocusContext.Provider>\n  );\n}\n\nexport default {\n  Context: FocusContext,\n  FocusRoot,\n};\n","import { FocusNode, NodeDefinition, Node, NodeNavigationItem } from '../types';\n\nexport default function nodeFromDefinition({\n  nodeDefinition,\n  parentNode,\n}: {\n  nodeDefinition: NodeDefinition;\n  parentNode: Node;\n}) {\n  const {\n    elRef,\n    onKey,\n    onArrow,\n    onLeft,\n    onRight,\n    onUp,\n    onDown,\n    onSelected,\n    onBack,\n\n    onFocused,\n    onBlurred,\n\n    defaultFocusColumn,\n    defaultFocusRow,\n\n    isExiting = false,\n\n    onMove,\n    onGridMove,\n  } = nodeDefinition;\n\n  const parentId = parentNode.focusId;\n  let nodeNavigationItem: NodeNavigationItem = 'default';\n\n  if (nodeDefinition.navigationStyle === 'grid') {\n    nodeNavigationItem = 'grid-container';\n  } else if (parentNode && parentNode.navigationStyle === 'grid') {\n    nodeNavigationItem = 'grid-row';\n  } else if (parentNode && parentNode.nodeNavigationItem === 'grid-row') {\n    nodeNavigationItem = 'grid-item';\n  }\n\n  const navigationStyle = nodeDefinition.navigationStyle ?? 'first-child';\n  const isGridContainer = navigationStyle === 'grid';\n\n  const defaultFocusColumnValue = defaultFocusColumn ?? 0;\n  const defaultFocusRowValue = defaultFocusRow ?? 0;\n\n  const node: FocusNode = {\n    elRef,\n    focusId: nodeDefinition.focusId,\n    isRoot: false,\n    parentId,\n\n    isExiting,\n\n    // These will be updated to their actual values within the call to `createNodes` below.\n    isFocused: false,\n    isFocusedLeaf: false,\n    active: false,\n\n    trap: Boolean(nodeDefinition.trap),\n    orientation: nodeDefinition.orientation ?? 'horizontal',\n    wrapping: Boolean(nodeDefinition.wrapping),\n    disabled: Boolean(nodeDefinition.initiallyDisabled),\n    navigationStyle,\n    nodeNavigationItem,\n    defaultFocusChild: nodeDefinition.defaultFocusChild,\n\n    defaultFocusColumn: defaultFocusColumnValue,\n    defaultFocusRow: defaultFocusRowValue,\n\n    forgetTrapFocusHierarchy: Boolean(\n      nodeDefinition.forgetTrapFocusHierarchy ?? false\n    ),\n    children: [],\n    focusedChildIndex: null,\n    prevFocusedChildIndex: null,\n    _gridColumnIndex: isGridContainer ? defaultFocusColumnValue : null,\n    _gridRowIndex: isGridContainer ? defaultFocusRowValue : null,\n    wrapGridHorizontal: Boolean(nodeDefinition.wrapGridHorizontal),\n    wrapGridVertical: Boolean(nodeDefinition.wrapGridVertical),\n    _focusTrapPreviousHierarchy: [],\n\n    onKey,\n    onArrow,\n    onLeft,\n    onRight,\n    onUp,\n    onDown,\n    onSelected,\n    onBack,\n\n    onFocused,\n    onBlurred,\n\n    onMove,\n    onGridMove,\n  };\n\n  return node;\n}\n","import { useEffect, useRef } from 'react';\n\nexport default function usePrevious<Value>(value: Value): Value | undefined {\n  const ref = useRef<Value>();\n\n  useEffect(() => {\n    ref.current = value;\n  });\n\n  return ref.current;\n}\n","import React, {\n  createElement,\n  useState,\n  useImperativeHandle,\n  useContext,\n  useEffect,\n  useRef,\n  useMemo,\n  forwardRef,\n} from 'react';\nimport FocusContext from './focus-context';\nimport nodeFromDefinition from './utils/node-from-definition';\nimport { warning } from './utils/warning';\nimport usePrevious from './hooks/internal/use-previous';\nimport {\n  FocusStore,\n  Id,\n  FocusNodeProps,\n  Node,\n  FocusNode as FocusNodeType,\n  NodeDefinition,\n  ProviderValue,\n  ReactNodeRef,\n} from './types';\n\nlet uniqueId = 0;\n\nfunction checkForUpdate({\n  focusStore,\n  id,\n  setNode,\n  currentNode,\n}: {\n  focusStore: FocusStore;\n  id: Id;\n  setNode: React.Dispatch<React.SetStateAction<FocusNodeType>>;\n  currentNode: Node;\n}) {\n  const state = focusStore.getState();\n  const newNode = state.nodes[id] as FocusNodeType;\n\n  if (newNode && newNode !== currentNode && !newNode.isExiting) {\n    setNode(newNode);\n  }\n}\n\nexport function FocusNode(\n  {\n    elementType = 'div',\n\n    focusId,\n    className = '',\n    children,\n    wrapping = false,\n    wrapGridHorizontal,\n    wrapGridVertical,\n    orientation,\n    isGrid = false,\n    isTrap = false,\n    forgetTrapFocusHierarchy = false,\n\n    defaultFocusColumn,\n    defaultFocusRow,\n\n    disabled,\n\n    onMountAssignFocusTo,\n    defaultFocusChild,\n\n    isExiting = false,\n\n    propsFromNode,\n\n    focusedClass = 'isFocused',\n    focusedLeafClass = 'isFocusedLeaf',\n    disabledClass = 'focusDisabled',\n    activeClass = 'isActive',\n\n    onKey,\n    onArrow,\n    onLeft,\n    onRight,\n    onUp,\n    onDown,\n    onSelected,\n    onBack,\n\n    onMove,\n    onGridMove,\n\n    onFocused,\n    onBlurred,\n\n    onClick,\n    onMouseOver,\n\n    ...otherProps\n  }: FocusNodeProps,\n  ref: ReactNodeRef\n) {\n  const elRef = useRef(null);\n\n  // We store the callbacks in a ref so that we can pass a wrapper function into the underlying\n  // focus node within the focus state. This wrapper function stays constant throughout the lifetime\n  // of the node, and that wrapper calls this ref.\n  // The reason for this roundabout solution is to avoid a situation of an infinite rerenders: if the node\n  // itself were updated when the callbacks changed, then this would cause all consumers of the store state\n  // to render. Unless consumers are using `useCallback`, this would recreate the handlers, creating an infinite\n  // loop.\n  const callbacksRef = useRef({\n    onKey,\n    onArrow,\n    onLeft,\n    onRight,\n    onUp,\n    onDown,\n    onSelected,\n    onBack,\n\n    onMove,\n    onGridMove,\n\n    onFocused,\n    onBlurred,\n\n    onClick,\n    onMouseOver,\n  });\n\n  useEffect(() => {\n    callbacksRef.current = {\n      onKey,\n      onArrow,\n      onLeft,\n      onRight,\n      onUp,\n      onDown,\n      onSelected,\n      onBack,\n\n      onMove,\n      onGridMove,\n\n      onFocused,\n      onBlurred,\n\n      onClick,\n      onMouseOver,\n    };\n  }, [\n    onKey,\n    onArrow,\n    onLeft,\n    onRight,\n    onUp,\n    onDown,\n    onSelected,\n    onBack,\n\n    onMove,\n    onGridMove,\n\n    onFocused,\n    onBlurred,\n\n    onClick,\n    onMouseOver,\n  ]);\n\n  useImperativeHandle(\n    ref,\n    // I may need to update this based on this comment to make TS happy:\n    // https://github.com/DefinitelyTyped/DefinitelyTyped/issues/46266#issuecomment-662543885\n    // However, this code works as expected so I'm @ts-ignoring it.\n    // @ts-ignore\n    () => {\n      return elRef.current;\n    }\n  );\n\n  const [nodeId] = useState(() => {\n    const nonStringFocusId =\n      typeof focusId !== 'string' && focusId !== undefined;\n    const reservedFocusId = focusId === 'root';\n    const emptyStringNode = focusId + '' === '';\n    const invalidNodeId =\n      nonStringFocusId || reservedFocusId || emptyStringNode;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (reservedFocusId) {\n        warning(\n          'A focus node with an invalid focus ID was created: \"root\". This is a reserved ID, so it has been ' +\n            'ignored. Please choose another ID if you wish to specify an ID.',\n          'ROOT_ID_WAS_PASSED'\n        );\n      }\n\n      if (nonStringFocusId || emptyStringNode) {\n        warning(\n          'A focus node with an invalid (non-string or empty string) focus ID was created. This is a not supported ID type (expected non-empty string), so it has been ' +\n            'ignored. Please choose another ID if you wish to specify an ID.',\n          'INVALID_FOCUS_ID_PASSED'\n        );\n      }\n    }\n\n    if (focusId && !invalidNodeId) {\n      return focusId;\n    } else {\n      const id = `node-${uniqueId}`;\n      uniqueId = uniqueId + 1;\n\n      return id;\n    }\n  });\n\n  const onClickRef = useRef(onClick);\n  const onMouseOverRef = useRef(onMouseOver);\n\n  onClickRef.current = onClick;\n  onMouseOverRef.current = onMouseOver;\n\n  const defaultForgetFocusTrap = isTrap ? false : undefined;\n  const defaultOrientation = !isGrid ? undefined : 'horizontal';\n\n  const contextValue = useContext(FocusContext.Context);\n  const [staticDefinitions] = useState(() => {\n    const wrapGridVerticalValue =\n      typeof wrapGridVertical === 'boolean' ? wrapGridVertical : wrapping;\n    const wrapGridHorizontalValue =\n      typeof wrapGridHorizontal === 'boolean' ? wrapGridHorizontal : wrapping;\n\n    function createCallbackWrapper(fnName: string) {\n      return function callbackWrapper(...args: any[]) {\n        // @ts-ignore\n        if (\n          callbacksRef.current &&\n          // @ts-ignore\n          typeof callbacksRef.current[fnName] === 'function'\n        ) {\n          // @ts-ignore\n          callbacksRef.current[fnName](...args);\n        }\n      };\n    }\n\n    const nodeDefinition: NodeDefinition = {\n      elRef,\n      focusId: nodeId,\n      orientation: orientation || defaultOrientation,\n      wrapping: Boolean(wrapping),\n      trap: Boolean(isTrap),\n      wrapGridHorizontal: wrapGridHorizontalValue,\n      wrapGridVertical: wrapGridVerticalValue,\n      forgetTrapFocusHierarchy:\n        forgetTrapFocusHierarchy !== undefined\n          ? forgetTrapFocusHierarchy\n          : defaultForgetFocusTrap,\n      navigationStyle: isGrid ? 'grid' : 'first-child',\n\n      defaultFocusColumn: defaultFocusColumn ?? 0,\n      defaultFocusRow: defaultFocusRow ?? 0,\n\n      onKey: createCallbackWrapper('onKey'),\n      onArrow: createCallbackWrapper('onArrow'),\n      onLeft: createCallbackWrapper('onLeft'),\n      onRight: createCallbackWrapper('onRight'),\n      onUp: createCallbackWrapper('onUp'),\n      onDown: createCallbackWrapper('onDown'),\n      onSelected: createCallbackWrapper('onSelected'),\n      onBack: createCallbackWrapper('onBack'),\n\n      onMove: createCallbackWrapper('onMove'),\n      onGridMove: createCallbackWrapper('onGridMove'),\n\n      initiallyDisabled: Boolean(disabled),\n      onMountAssignFocusTo,\n      defaultFocusChild,\n\n      isExiting,\n\n      onFocused,\n      onBlurred,\n    };\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (isGrid && orientation) {\n        warning(\n          'You passed the orientation prop to a grid focus node. ' +\n            'This prop has no effect on grid nodes, but it may represent an error in your code. ' +\n            `This node has a focus ID of ${nodeId}.`,\n          'ORIENTATION_ON_GRID'\n        );\n      }\n\n      if (isGrid && defaultFocusChild) {\n        warning(\n          'You passed the defaultFocusChild prop to a grid focus node. ' +\n            'This prop has no effect on grid nodes, but it may represent an error in your code. ' +\n            `This node has a focus ID of ${nodeId}.`,\n          'PREFERRED_CHILD_INDEX_ON_GRID'\n        );\n      }\n\n      if (onGridMove && !isGrid) {\n        warning(\n          'You passed the onGridMove prop to a node that is not a grid. ' +\n            'This will have no effect, but it may represent an error in your code. ' +\n            `This node has a focus ID of ${nodeId}.`,\n          'GRID_MOVE_NOT_ON_GRID'\n        );\n      } else if (onMove && isGrid) {\n        warning(\n          'You passed the onMove prop to a grid Focus Node. ' +\n            'onMove does not work on grid nodes. Did you mean to pass onGridMove instead? ' +\n            `This node has a focus ID of ${nodeId}.`,\n          'ON_MOVE_ON_GRID'\n        );\n      }\n\n      if (forgetTrapFocusHierarchy && !nodeDefinition.trap) {\n        warning(\n          'You passed the forgetTrapFocusHierarchy prop to a focus node that is not a trap. ' +\n            'This will have no effect, but it may represent an error in your code. ' +\n            `This node has a focus ID of ${nodeId}.`,\n          'RESTORE_TRAP_FOCUS_WITHOUT_TRAP'\n        );\n      }\n    }\n\n    if (!contextValue) {\n      if (process.env.NODE_ENV !== 'production') {\n        warning(\n          'A FocusProvider was not found in the tree. Did you forget to mount it?',\n          'NO_FOCUS_PROVIDER_DETECTED'\n        );\n      }\n\n      throw new Error('No FocusProvider.');\n    }\n\n    const { store, focusDefinitionHierarchy, focusNodesHierarchy } =\n      contextValue;\n\n    const parentNode = focusNodesHierarchy[focusNodesHierarchy.length - 1];\n    const initialNode = nodeFromDefinition({\n      nodeDefinition,\n      parentNode,\n    });\n\n    const newDefinitionHierarchy =\n      focusDefinitionHierarchy.concat(nodeDefinition);\n\n    const newNodesHierarchy = focusNodesHierarchy.concat(initialNode);\n\n    const providerValue: ProviderValue = {\n      store,\n      focusDefinitionHierarchy: newDefinitionHierarchy,\n      focusNodesHierarchy: newNodesHierarchy,\n    };\n\n    return {\n      nodeDefinition,\n      initialNode,\n      providerValue,\n    };\n  });\n\n  const { store } = contextValue as ProviderValue;\n\n  const [node, setNode] = useState<FocusNodeType>(() => {\n    return staticDefinitions.initialNode;\n  });\n\n  const computedProps = useMemo(() => {\n    if (typeof propsFromNode === 'function') {\n      return propsFromNode(node);\n    }\n    return {};\n  }, [node, propsFromNode]);\n\n  const nodeRef = useRef(node);\n  nodeRef.current = node;\n\n  let nodeExistsInTree = useRef(false);\n\n  const dynamicProps = useMemo(() => {\n    return {\n      disabled: Boolean(disabled),\n      isExiting: Boolean(isExiting),\n      defaultFocusColumn,\n      defaultFocusRow,\n      wrapping,\n      trap: isTrap,\n      forgetTrapFocusHierarchy,\n      defaultFocusChild,\n    };\n  }, [\n    disabled,\n    isExiting,\n    defaultFocusColumn,\n    defaultFocusRow,\n    wrapping,\n    isTrap,\n    forgetTrapFocusHierarchy,\n    defaultFocusChild,\n  ]);\n\n  const prevDynamicProps = usePrevious(dynamicProps);\n\n  useEffect(() => {\n    // This ensures that we don't check for updates on the first render.\n    if (!nodeExistsInTree.current) {\n      return;\n    }\n\n    const actualUpdate = {};\n    let hasUpdate = false;\n\n    for (let x in dynamicProps) {\n      // @ts-ignore\n      const currentProp = dynamicProps[x];\n      // @ts-ignore\n      const prevProp = prevDynamicProps[x];\n\n      if (currentProp !== prevProp) {\n        hasUpdate = true;\n        // @ts-ignore\n        actualUpdate[x] = currentProp;\n      }\n    }\n\n    if (hasUpdate) {\n      store.updateNode(nodeId, actualUpdate);\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [dynamicProps, prevDynamicProps]);\n\n  useEffect(() => {\n    store.createNodes(\n      staticDefinitions.providerValue.focusNodesHierarchy,\n      staticDefinitions.providerValue.focusDefinitionHierarchy\n    );\n    nodeExistsInTree.current = true;\n\n    const unsubscribe = store.subscribe(() =>\n      checkForUpdate({\n        focusStore: store,\n        id: nodeId,\n        setNode,\n        currentNode: nodeRef.current,\n      })\n    );\n\n    // We need to manually check for updates. This is because parent nodes won't receive the update otherwise.\n    // By the time a parent's useEffect runs, their children will have already instantiated them, so the store\n    // will not call \"update\" as a result of `.createNodes()`\n    checkForUpdate({\n      focusStore: store,\n      id: nodeId,\n      setNode,\n      currentNode: nodeRef.current,\n    });\n\n    return () => {\n      nodeExistsInTree.current = false;\n      store.deleteNode(nodeId);\n      unsubscribe();\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  const classNameString = `${className} ${node.isFocused ? focusedClass : ''} ${\n    node.isFocusedLeaf ? focusedLeafClass : ''\n  } ${node.disabled ? disabledClass : ''} ${\n    computedProps && typeof computedProps.className === 'string'\n      ? computedProps.className\n      : ''\n  } ${node.active ? activeClass : ''}`;\n\n  return (\n    <FocusContext.Context.Provider value={staticDefinitions.providerValue}>\n      {createElement(elementType, {\n        ...otherProps,\n        ...computedProps,\n        ref: elRef,\n        className: classNameString,\n        children,\n        onMouseOver(e: any) {\n          // We only set focus via mouse to the leaf nodes that aren't disabled\n          const focusState = staticDefinitions.providerValue.store.getState();\n\n          if (\n            nodeRef.current &&\n            nodeRef.current.children.length === 0 &&\n            !nodeRef.current.disabled &&\n            focusState._hasPointerEventsEnabled &&\n            focusState.interactionMode === 'pointer' &&\n            nodeExistsInTree.current\n          ) {\n            staticDefinitions.providerValue.store.setFocus(nodeId);\n          }\n\n          if (typeof onMouseOverRef.current === 'function') {\n            onMouseOverRef.current(e);\n          }\n        },\n        onClick(e: any) {\n          if (typeof onClickRef.current === 'function') {\n            onClickRef.current(e);\n          }\n\n          const isLeaf =\n            nodeRef.current && nodeRef.current.children.length === 0;\n          const isDisabled = nodeRef.current && nodeRef.current.disabled;\n          if (!isLeaf || isDisabled) {\n            return;\n          }\n\n          const focusState = staticDefinitions.providerValue.store.getState();\n\n          if (\n            !focusState._hasPointerEventsEnabled ||\n            !nodeExistsInTree.current ||\n            focusState.interactionMode !== 'pointer'\n          ) {\n            return;\n          }\n\n          if (\n            nodeRef.current &&\n            typeof nodeRef.current.onSelected === 'function'\n          ) {\n            // Note: `bubbleKey` fires the events up whatever the current focus hierarchy is, so it might seem\n            // weird that we can just assume that this node is always the leaf node of the current hierarchy.\n            //\n            // It turns out that this works because:\n            //   - when pointer events are enabled we always set focus to leaf nodes in `onMouseOver`\n            //   - this lib is not intended for touchscreen environments, so all click events will be preceded by a hover\n            //   - these pointer events are only handled on leaf nodes\n            //\n            // If any of those conditions ever change then we will need to revisit this, but for now it should be fine.\n            staticDefinitions.providerValue.store.processKey.select();\n          }\n\n          staticDefinitions.providerValue.store.handleSelect(nodeId);\n        },\n      })}\n    </FocusContext.Context.Provider>\n  );\n}\n\nconst ForwardedFocusNode = forwardRef(FocusNode);\nexport default ForwardedFocusNode;\n","import { useContext, useState, useEffect, useRef } from 'react';\nimport FocusContext from '../focus-context';\nimport { warning } from '../utils/warning';\nimport { Id, Node } from '../types';\n\nexport default function useFocusNodeById(focusId: Id): Node | null {\n  const contextValue = useContext(FocusContext.Context);\n\n  const [focusNode, setFocusNode] = useState<Node | null>(() => {\n    if (!contextValue) {\n      if (process.env.NODE_ENV !== 'production') {\n        warning(\n          'A FocusProvider was not found in the tree. Did you forget to mount it?',\n          'NO_FOCUS_PROVIDER_DETECTED'\n        );\n      }\n\n      return null;\n    } else {\n      if (process.env.NODE_ENV !== 'production') {\n        if (typeof focusId !== 'string') {\n          warning(\n            `You passed a non-string focus ID to useFocusNodeById: ${focusId}. Focus IDs are always strings. ` +\n              'This may represent an error in your code.',\n            'FOCUS_ID_NOT_STRING'\n          );\n        }\n      }\n\n      const focusState = contextValue.store.getState();\n      const possibleNode = focusState.nodes[focusId];\n      return possibleNode ?? null;\n    }\n  });\n\n  const focusNodeRef = useRef(focusNode);\n  focusNodeRef.current = focusNode;\n\n  const focusIdRef = useRef(focusId);\n  focusIdRef.current = focusId;\n\n  function checkForSync() {\n    if (!contextValue) {\n      return;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof focusIdRef.current !== 'string') {\n        warning(\n          `You passed a non-string focus ID to useFocusNodeById: ${focusId}. Focus IDs are always strings. ` +\n            'This may represent an error in your code.',\n          'FOCUS_ID_NOT_STRING'\n        );\n      }\n    }\n\n    const currentNode =\n      contextValue.store.getState().nodes[focusIdRef.current] ?? null;\n    if (currentNode !== focusNodeRef.current) {\n      setFocusNode(currentNode);\n    }\n  }\n\n  useEffect(checkForSync, [focusId]);\n\n  useEffect(() => {\n    if (!contextValue) {\n      return;\n    }\n\n    checkForSync();\n    const unsubscribe = contextValue.store.subscribe(checkForSync);\n\n    return () => {\n      unsubscribe();\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  return focusNode;\n}\n","import { useEffect } from 'react';\nimport { warning } from '../utils/warning';\nimport useFocusNodeById from './use-focus-node-by-id';\nimport { Id, Node } from '../types';\n\nexport default function useFocusNode(nodeId: Id): Node | null {\n  useEffect(() => {\n    warning(\n      `You used the hook \\`useFocusNode\\`. This hook has been renamed to \\`useFocusNodeById\\`. Please refactor your code to use the new hook instead.`,\n      'USE_FOCUS_NODE_RENAMED'\n    );\n  }, []);\n\n  return useFocusNodeById(nodeId);\n}\n","import { useContext, useEffect, useState, useRef } from 'react';\nimport FocusContext from '../focus-context';\nimport { warning } from '../utils/warning';\nimport { Node, NodeHierarchy } from '../types';\n\nfunction hierarchiesAreEqual(\n  old: Node[] = [],\n  current: NodeHierarchy = []\n): boolean {\n  // Hierarchies are only equal when the lengths are the same, and...\n  if (old.length !== current.length) {\n    return false;\n  }\n\n  const oldFocusedExact = old[old.length - 1] || {};\n\n  // ...when the last IDs match\n  if (oldFocusedExact.focusId !== current[current.length - 1]) {\n    return false;\n  }\n\n  return true;\n}\n\nexport default function useFocusHierarchy(): Node[] {\n  const contextValue = useContext(FocusContext.Context);\n\n  const [focusHierarchy, setFocusHierarchy] = useState<Node[]>(() => {\n    if (!contextValue) {\n      if (process.env.NODE_ENV !== 'production') {\n        warning(\n          'A FocusProvider was not found in the tree. Did you forget to mount it?',\n          'NO_FOCUS_PROVIDER_DETECTED'\n        );\n      }\n      return [];\n    } else {\n      const focusState = contextValue.store.getState();\n      return focusState.focusHierarchy.map(\n        (nodeId) => focusState.nodes[nodeId]\n      ) as Node[];\n    }\n  });\n\n  const focusHierarchyRef = useRef(focusHierarchy);\n  focusHierarchyRef.current = focusHierarchy;\n\n  function checkForSync() {\n    if (!contextValue) {\n      return;\n    }\n\n    const currentState = contextValue.store.getState();\n\n    const currentHierarchy = contextValue.store.getState().focusHierarchy;\n    if (!hierarchiesAreEqual(focusHierarchyRef.current, currentHierarchy)) {\n      setFocusHierarchy(\n        currentState.focusHierarchy.map(\n          (nodeId) => currentState.nodes[nodeId]\n        ) as Node[]\n      );\n    }\n  }\n\n  useEffect(() => {\n    if (!contextValue) {\n      return;\n    }\n\n    checkForSync();\n    const unsubscribe = contextValue.store.subscribe(checkForSync);\n\n    return () => {\n      unsubscribe();\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  return focusHierarchy;\n}\n","import { useMemo } from 'react';\nimport { Node } from '../types';\nimport useFocusHierarchy from './use-focus-hierarchy';\nimport useFocusNodeById from './use-focus-node-by-id';\n\nexport default function useLeafFocusedNode(): Node | null {\n  const focusHierarchy = useFocusHierarchy();\n\n  const leafId = useMemo(() => {\n    return focusHierarchy?.[focusHierarchy.length - 1]?.focusId;\n  }, [focusHierarchy]);\n\n  const leafFocusedNode = useFocusNodeById(leafId ?? '');\n\n  return leafFocusedNode;\n}\n","import { useContext, useState, useEffect, useRef } from 'react';\nimport FocusContext from '../focus-context';\nimport { warning } from '../utils/warning';\nimport { Node } from '../types';\n\nexport default function useActiveNode(): Node | null {\n  const contextValue = useContext(FocusContext.Context);\n\n  const [focusNode, setFocusNode] = useState<Node | null>(() => {\n    if (!contextValue) {\n      if (process.env.NODE_ENV !== 'production') {\n        warning(\n          'A FocusProvider was not found in the tree. Did you forget to mount it?',\n          'NO_FOCUS_PROVIDER_DETECTED'\n        );\n      }\n\n      return null;\n    } else {\n      const focusState = contextValue.store.getState();\n\n      if (focusState.activeNodeId === null) {\n        return null;\n      }\n\n      const possibleNode = focusState.nodes[focusState.activeNodeId];\n      return possibleNode ?? null;\n    }\n  });\n\n  const focusNodeRef = useRef(focusNode);\n  focusNodeRef.current = focusNode;\n\n  function checkForSync() {\n    if (!contextValue) {\n      return;\n    }\n\n    const currentState = contextValue.store.getState();\n\n    if (!currentState.activeNodeId) {\n      setFocusNode(null);\n      return;\n    }\n\n    const currentNode = currentState.nodes[currentState.activeNodeId] ?? null;\n    if (currentNode !== focusNodeRef.current) {\n      setFocusNode(currentNode);\n    }\n  }\n\n  useEffect(() => {\n    if (!contextValue) {\n      return;\n    }\n\n    checkForSync();\n    const unsubscribe = contextValue.store.subscribe(checkForSync);\n\n    return () => {\n      unsubscribe();\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  return focusNode;\n}\n","import { useContext } from 'react';\nimport FocusContext from '../focus-context';\nimport { warning } from '../utils/warning';\nimport { FocusStore } from '../types';\n\nexport default function useFocusStoreDangerously(): FocusStore {\n  const contextValue = useContext(FocusContext.Context);\n\n  if (!contextValue) {\n    if (process.env.NODE_ENV !== 'production') {\n      warning(\n        'A FocusProvider was not found in the tree. Did you forget to mount it?',\n        'NO_FOCUS_PROVIDER_DETECTED'\n      );\n    }\n\n    throw new Error('No FocusProvider.');\n  }\n\n  // @ts-ignore\n  return contextValue.store;\n}\n","import { useContext } from 'react';\nimport FocusContext from '../focus-context';\nimport { warning } from '../utils/warning';\nimport { Id } from '../types';\n\nexport default function useSetFocus(): (focusId: Id) => void {\n  const contextValue = useContext(FocusContext.Context);\n\n  if (!contextValue) {\n    if (process.env.NODE_ENV !== 'production') {\n      warning(\n        'A FocusProvider was not found in the tree. Did you forget to mount it?',\n        'NO_FOCUS_PROVIDER_DETECTED'\n      );\n    }\n\n    throw new Error('No FocusProvider.');\n  }\n\n  // @ts-ignore\n  return contextValue.store.setFocus;\n}\n","import { useEffect } from 'react';\nimport usePrevious from './use-previous';\n\ntype ComparatorFn<Value> = (a: Value, b: Value | undefined) => boolean;\n\nconst isEqual: ComparatorFn<any> = (a, b) => a === b;\n\nexport default function useChange<Value>(\n  val: Value,\n  callback: (currentValue: Value, previousValue: Value | undefined) => void,\n  comparator: ComparatorFn<Value> = isEqual\n): void {\n  const previous = usePrevious(val);\n\n  useEffect(() => {\n    if (typeof callback === 'function' && typeof comparator === 'function') {\n      if (!comparator(val, previous)) {\n        callback(val, previous);\n      }\n    }\n  }, [val, previous, comparator, callback]);\n}\n","import { useRef, useState } from 'react';\nimport useOnChange from './internal/use-on-change';\nimport useFocusNodeById from './use-focus-node-by-id';\nimport { warning } from '../utils/warning';\nimport { Id, Node } from '../types';\n\ntype EventCallback = (node: Node) => void;\n\ninterface Events {\n  focus?: EventCallback;\n  blur?: EventCallback;\n\n  active?: EventCallback;\n  inactive?: EventCallback;\n\n  disabled?: EventCallback;\n  enabled?: EventCallback;\n}\n\nexport default function useFocusEvents(nodeId: Id, events: Events = {}): void {\n  const [constantNodeId] = useState(nodeId);\n\n  const node = useFocusNodeById(constantNodeId);\n  const nodeRef = useRef(node);\n  nodeRef.current = node;\n\n  const eventsRef = useRef(events);\n  eventsRef.current = events;\n\n  // This pattern allows the `focus` hook to be called even on mount.\n  // When the node doesn't exist, we set this to false. Then, when the initial\n  // mounting is done, `node.isFocused` is true, and the callbacks fire.\n  const isFocused = Boolean(node && node.isFocused);\n\n  // This ensures that the enabled/disabled hooks are *not* called on mount.\n  // This way, `disabled/enabled` are only called when that state actually changes\n  let isDisabled;\n  if (!node) {\n    isDisabled = null;\n  } else {\n    isDisabled = node.disabled;\n  }\n\n  // For active, we also wouldn't want it to be called on mount, but it's not possible\n  // for a node to be mounted as active, so this simpler logic gives us the desired behavior.\n  const isActive = Boolean(node && node.active);\n\n  useOnChange(nodeId, (currentId, prevId) => {\n    if (typeof prevId !== 'string') {\n      return;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (currentId !== prevId) {\n        warning(\n          `The nodeId passed into useFocusEvents changed. This change has been ignored: the nodeId cannot be changed.`,\n          'FOCUS_EVENTS_NODE_ID_CHANGED'\n        );\n      }\n    }\n  });\n\n  useOnChange(isFocused, (currentIsFocused) => {\n    if (nodeRef.current) {\n      if (currentIsFocused && typeof eventsRef.current.focus === 'function') {\n        eventsRef.current.focus(nodeRef.current);\n      } else if (\n        !currentIsFocused &&\n        typeof eventsRef.current.blur === 'function'\n      ) {\n        eventsRef.current.blur(nodeRef.current);\n      }\n    }\n  });\n\n  useOnChange(isDisabled, (currentIsDisabled, prevIsDisabled) => {\n    if (prevIsDisabled === undefined || prevIsDisabled == null) {\n      return;\n    }\n\n    if (nodeRef.current) {\n      if (\n        currentIsDisabled &&\n        typeof eventsRef.current.disabled === 'function'\n      ) {\n        eventsRef.current.disabled(nodeRef.current);\n      } else if (\n        !currentIsDisabled &&\n        typeof eventsRef.current.enabled === 'function'\n      ) {\n        eventsRef.current.enabled(nodeRef.current);\n      }\n    }\n  });\n\n  useOnChange(isActive, (currentIsActive) => {\n    if (nodeRef.current) {\n      if (currentIsActive && typeof eventsRef.current.active === 'function') {\n        eventsRef.current.active(nodeRef.current);\n      } else if (\n        !currentIsActive &&\n        typeof eventsRef.current.inactive === 'function'\n      ) {\n        eventsRef.current.inactive(nodeRef.current);\n      }\n    }\n  });\n}\n","import useFocusStoreDangerously from './use-focus-store-dangerously';\n\nexport default function useProcessKey() {\n  const focusStore = useFocusStoreDangerously();\n  return focusStore.processKey;\n}\n","import FocusContext from './focus-context';\nexport { default as FocusNode } from './focus-node';\nexport { default as useFocusNodeById } from './hooks/use-focus-node-by-id';\nexport { default as useFocusNode } from './hooks/use-focus-node';\nexport { default as useLeafFocusedNode } from './hooks/use-leaf-focused-node';\nexport { default as useActiveNode } from './hooks/use-active-node';\nexport { default as useFocusHierarchy } from './hooks/use-focus-hierarchy';\nexport { default as useFocusStoreDangerously } from './hooks/use-focus-store-dangerously';\nexport { default as useSetFocus } from './hooks/use-set-focus';\nexport { default as useFocusEvents } from './hooks/use-focus-events';\nexport { default as useProcessKey } from './hooks/use-process-key';\n\nconst FocusRoot = FocusContext.FocusRoot;\nexport { FocusRoot };\n"],"names":["codeCache","warning","message","code","console","error","Error","e","clamp","x","min","max","RangeError","getWrappedIndex","index","size","Math","floor","getIndex","arrayLength","wrap","createNodeDefinitionHierarchy","focusState","nodeDefinitionHierarchy","nodeHierarchy","nodeUpdates","onMountAssignFocusToReturn","onMountAssignFocusTo","shouldLockFocus","_updatingFocusIsLocked","i","length","node","isLastNode","nodeDefinition","currentNode","nodes","focusId","isCreatingNewNode","undefined","navigationStyle","defaultFocusColumn","defaultFocusRow","gridNode","rowIndex","children","wrapGridVertical","newRowNodeId","rowNode","rowNodeChildrenLength","columnIndex","wrapGridHorizontal","itemIndex","focusedItemId","isFinalNode","setFocusGoal","parentLoopIndex","parentDefinition","parentId","parentNode","parentChildren","newParentChildren","Array","isArray","concat","Object","keys","assignFocusTo","nodeIdIsFocused","focusHierarchy","nodeId","idIndex","indexOf","nodeCanReceiveIndirectFocus","disabled","isExiting","trap","someChildIsEnabled","childId","childNode","childCanReceiveFocus","getParents","currentFocusHierarchy","getChildren","orientation","preferEnd","preferredChildren","nodeChildren","filter","nextPreferredChildren","preferredRowIndex","rowId","row","preferredColumnIndex","columnId","nextChildId","numericdefaultFocusChild","defaultFocusChild","Number","isFinite","isValiddefaultFocusChild","childIndex","maxChildIndex","possibleId","slice","isGridNavigation","useLastNode","lastIndex","generateFocusHierarchyFromId","propagateFromId","_focusTrapPreviousHierarchy","computeFocusHierarchy","explicitlyAssignFocus","focusedNodeId","assignedNode","getFocusDiff","prevFocusHierarchy","largerIndex","splitIndex","NaN","prevId","currentId","isNaN","blur","focus","unchanged","getParentGrid","rowChildren","gridNodeId","gridChildren","_gridColumnIndex","_gridRowIndex","getNodesFromFocusChange","blurHierarchy","unchangedHierarchy","result","isFocusedLeaf","prevFocusedChildIndex","focusedChildIndex","nodeToUpdate","isFocused","forgetTrapFocusHierarchy","childHierarchy","isLeafNode","nodeNavigationItem","updatedGridNode","bubbleEvent","nodeIds","callbackName","arg","reverse","forEach","targetNodeId","cb","argToUse","emitFocusStateEvents","blurNodeId","focusNodeId","blurNode","focusNode","updateFocus","newFocusHierarchy","hierarchyHasChanged","newNodes","newState","activeNodeId","interactionMode","_hasPointerEventsEnabled","recursivelyDeleteChildren","childChildren","deleteNode","id","stateAfterDeletion","nodeWasFocused","navigateFromTargetNode","targetNode","direction","distance","wrapping","allParentsChildren","parentsChildren","isEnabled","canReceiveFocusFromArrow","newIndex","newFocusedId","newFocusedNode","defaultNavigation","arrow","stateChanged","onMove","nextChildIndex","prevChildIndex","currentFocusedNodeId","currentFocusedNode","prevFocusedNodeId","prevFocusedNode","prevChildNode","nextChildNode","getGridFocusData","isVertical","isForward","currentRowIndex","currentColumnIndex","actualRowIndex","actualColumnIndex","newRowIndex","newColumnIndex","newRowNode","newItemNodeId","targetFocusId","gridNavigation","gridFocusData","updatedFocusTree","rowChanged","columnChanged","changeOccurred","onGridMove","prevRowIndex","nextRowIndex","prevColumnIndex","nextColumnIndex","getGridParent","focusedNode","rowNodeId","testForGrid","activeGridNodes","isAtFirstRow","isAtLastRow","isAtFirstColumn","isAtLastColumn","movingBackwardVerticallyOnFirstRow","movingForwardVerticallyOnLastRow","movingBackwardHorizontallyOnFirstColumn","movingForwardHorizontallyOnLastColumn","wouldHandleVertical","wouldHandleHorizontal","movementIsWithinTheGrid","style","getDefaultNavTarget","unfilteredChildren","movingForwardAndOnLastNode","movingBackwardAndOnFirstNode","processNode","isGridNode","gridHandle","defaultNavigationTargetNode","determineNavigationStyle","handleArrow","validateNode","enabledNodeChildren","childNodeId","isRoot","enforceStateStructure","values","recursivelyUpdateChildren","update","updatedChildrenNodes","executeFunction","fn","isArrow","key","preventDefault","stopPropagation","bubbleKey","focusTree","state","getState","isSelect","isBack","defaultPrevented","propagationStopped","reverseFocusHierarchy","handleSelect","dynamicNodeProps","createFocusStore","pointerEvents","currentState","root","elRef","current","active","listeners","subscribe","listener","push","subscribed","unsubscribe","splice","onUpdate","createNodes","createNode","hasNodesToUpdate","Boolean","isUnlockingFocus","possibleNewState","nodeHierarchyIds","map","focusedItemIndex","assigningFocusOnMount","findIndex","v","updatedFocusState","deleteNodeUtil","setFocus","setInteractionMode","newMode","newFocusState","updateNode","updateHasDisabled","updateHasExiting","nodeChanged","some","prop","updateValue","updateValueExists","newNode","updatedChildren","recursiveUpdate","find","updatedState","handleArrowUtil","leafNodeId","leafNode","previousActiveNode","isListeningToPointerEvents","configurePointerEvents","enablePointerEvents","existingState","addPointerListeners","removePointerListeners","handlingPointerEvent","onPointerEvent","requestAnimationFrame","window","addEventListener","removeEventListener","destroy","internalProcessKey","_focusStore","processKey","select","back","down","left","right","up","throttle","func","wait","options","context","args","timeout","previous","later","leading","Date","now","apply","remaining","arguments","clearTimeout","trailing","setTimeout","ArrowUp","ArrowDown","ArrowLeft","ArrowRight","Enter","Escape","focusLrud","focusStore","lrudMapping","throttleDelay","keydownHandler","bindingName","keyToBindingMap","binding","FocusContext","React","createContext","FocusRoot","rootElRef","useRef","useState","store","focusDefinitionHierarchy","focusNodesHierarchy","providerValue","useEffect","lrud","lrudInput","Provider","value","Context","nodeFromDefinition","onKey","onArrow","onLeft","onRight","onUp","onDown","onSelected","onBack","onFocused","onBlurred","isGridContainer","defaultFocusColumnValue","defaultFocusRowValue","initiallyDisabled","usePrevious","ref","uniqueId","checkForUpdate","setNode","FocusNode","elementType","className","isGrid","isTrap","propsFromNode","focusedClass","focusedLeafClass","disabledClass","activeClass","onClick","onMouseOver","otherProps","callbacksRef","useImperativeHandle","nonStringFocusId","reservedFocusId","emptyStringNode","invalidNodeId","onClickRef","onMouseOverRef","defaultForgetFocusTrap","defaultOrientation","contextValue","useContext","wrapGridVerticalValue","wrapGridHorizontalValue","createCallbackWrapper","fnName","callbackWrapper","initialNode","newDefinitionHierarchy","newNodesHierarchy","staticDefinitions","computedProps","useMemo","nodeRef","nodeExistsInTree","dynamicProps","prevDynamicProps","actualUpdate","hasUpdate","currentProp","prevProp","classNameString","createElement","isLeaf","isDisabled","ForwardedFocusNode","forwardRef","useFocusNodeById","possibleNode","setFocusNode","focusNodeRef","focusIdRef","checkForSync","useFocusNode","hierarchiesAreEqual","old","oldFocusedExact","useFocusHierarchy","setFocusHierarchy","focusHierarchyRef","currentHierarchy","useLeafFocusedNode","leafId","leafFocusedNode","useActiveNode","useFocusStoreDangerously","useSetFocus","isEqual","a","b","useChange","val","callback","comparator","useFocusEvents","events","constantNodeId","eventsRef","isActive","useOnChange","currentIsFocused","currentIsDisabled","prevIsDisabled","enabled","currentIsActive","inactive","useProcessKey"],"mappings":"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"}
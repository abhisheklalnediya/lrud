{"version":3,"file":"lrud.cjs.production.min.js","sources":["../src/utils/clamp.ts","../src/utils/get-index.ts","../src/utils/node-can-receive-indirect-focus.ts","../src/update-focus/get-nodes-from-focus-change.ts","../src/update-focus/bubble-focus-event.ts","../src/update-focus/update-focus.ts","../src/update-focus/compute-focus-hierarchy.ts","../src/utils/tree-navigation.ts","../src/update-focus/get-focus-diff.ts","../src/update-focus/emit-focus-state-events.ts","../src/handle-arrow/determine-navigation-style/get-grid-parent.ts","../src/utils/bubble-key-input.ts","../src/focus-store.ts","../src/lrud-input/key-to-binding-map.ts","../src/focus-context.tsx","../src/utils/create-node.ts","../src/utils/delete-node.ts","../src/utils/node-id-is-focused.ts","../src/utils/recursively-update-node.ts","../src/handle-arrow/handle-arrow.ts","../src/handle-arrow/determine-navigation-style/determine-navigation-style.ts","../src/handle-arrow/determine-navigation-style/test-for-grid.ts","../src/handle-arrow/determine-navigation-style/get-default-nav-target.ts","../src/handle-arrow/default-navigation/default-navigation.ts","../src/handle-arrow/default-navigation/navigate-from-target-node.ts","../src/handle-arrow/grid-navigation/grid-navigation.ts","../src/utils/get-grid-focus-data.ts","../src/lrud-input/focus-lrud.ts","../src/lrud-input/throttle.ts","../src/hooks/internal/use-previous.ts","../src/focus-node.tsx","../src/utils/node-from-definition.ts","../src/hooks/use-focus-node-by-id.ts","../src/hooks/use-focus-hierarchy.ts","../src/hooks/use-focus-store-dangerously.ts","../src/hooks/internal/use-on-change.ts","../src/index.ts","../src/hooks/use-active-node.ts","../src/hooks/use-focus-events.ts","../src/hooks/use-focus-node.ts","../src/hooks/use-leaf-focused-node.ts","../src/hooks/use-process-key.ts","../src/hooks/use-set-focus.ts"],"sourcesContent":["// From Sindre's math-clamp library\n// https://github.com/sindresorhus/math-clamp\n// License: https://github.com/sindresorhus/math-clamp/blob/9f17aa114bbdaa99f6ce62f2fed860acaab4d00b/license\n//\n// Will one day be replaced with:\n// https://github.com/rwaldron/proposal-math-extensions\nexport default function clamp(x: number, min: number, max: number): number {\n  if (min > max) {\n    throw new RangeError('`min` should be lower than `max`');\n  }\n\n  if (x < min) {\n    return min;\n  }\n\n  if (x > max) {\n    return max;\n  }\n\n  return x;\n}\n","import clamp from './clamp';\n\nfunction getWrappedIndex(index: number, size: number): number {\n  return index - Math.floor(index / size) * size;\n}\n\nexport default function getIndex(\n  arrayLength: number,\n  index: number,\n  wrap: boolean = false\n) {\n  if (wrap) {\n    return getWrappedIndex(index, arrayLength);\n  } else {\n    return clamp(index, 0, arrayLength - 1);\n  }\n}\n","import { FocusState, Node } from '../types';\n\n// \"Indirect focus\" here means:\n// 1. receiving focus when a parent node receives focus, either through LRUD input or through an explicit call\n//    to `setFocus`\n// 2. receiving focus after being mounted\n//\n// This function ensures that things like disabled nodes don't receive focus when LRUD is input or when they mount.\n\nexport default function nodeCanReceiveIndirectFocus(\n  focusState: FocusState,\n  node?: Node\n) {\n  if (!node) {\n    return false;\n  }\n\n  if (node.disabled || node.isExiting || node.trap) {\n    return false;\n  }\n\n  // This guards against a situation where a child is focusable, but\n  // it is not a leaf and has no focusable children.\n  const children = node.children || [];\n  if (children.length === 0) {\n    return true;\n  } else {\n    let someChildIsEnabled = false;\n\n    for (let i = 0; i < children.length; i++) {\n      const childId = children[i];\n      const childNode = focusState.nodes[childId];\n\n      const childCanReceiveFocus = nodeCanReceiveIndirectFocus(\n        focusState,\n        childNode\n      );\n\n      if (childCanReceiveFocus) {\n        someChildIsEnabled = true;\n        break;\n      }\n    }\n\n    if (!someChildIsEnabled) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","import {\n  NodeMap,\n  Node,\n  Id,\n  FocusNode,\n  FocusState,\n  NodeHierarchy,\n} from '../types';\n\ninterface GetNodesFromFocusChangeOptions {\n  focusState: FocusState;\n  blurHierarchy: NodeHierarchy;\n  focusHierarchy: NodeHierarchy;\n  unchangedHierarchy: NodeHierarchy;\n}\n\nfunction getParentGrid(nodes: NodeMap, node: Node): FocusNode {\n  const parentId = node.parentId as Id;\n  const rowNode = nodes[parentId] as FocusNode;\n\n  const rowChildren = rowNode.children.filter((nodeId) => {\n    const node = nodes[nodeId];\n    return node && !node.disabled && !node.isExiting;\n  });\n\n  const columnIndex = rowChildren.indexOf(node.focusId);\n\n  const gridNodeId = rowNode.parentId as Id;\n  const gridNode = nodes[gridNodeId] as FocusNode;\n\n  const gridChildren = gridNode.children.filter((nodeId) => {\n    const node = nodes[nodeId];\n    return node && !node.disabled && !node.isExiting;\n  });\n\n  const rowIndex = gridChildren.indexOf(rowNode.focusId);\n\n  return {\n    ...gridNode,\n    _gridColumnIndex: columnIndex,\n    _gridRowIndex: rowIndex,\n  };\n}\n\nexport default function getNodesFromFocusChange({\n  focusState,\n  blurHierarchy,\n  focusHierarchy,\n  unchangedHierarchy,\n}: GetNodesFromFocusChangeOptions): NodeMap {\n  let result: NodeMap = {};\n\n  for (let i = 0; i < unchangedHierarchy.length; i++) {\n    const nodeId = unchangedHierarchy[i];\n    const node = focusState.nodes[nodeId];\n\n    if (!node) {\n      continue;\n    }\n\n    const isLastNode = i === unchangedHierarchy.length - 1;\n    const isFocusedLeaf = isLastNode && !focusHierarchy.length;\n\n    if (node.isFocusedLeaf !== isFocusedLeaf) {\n      result[nodeId] = {\n        ...node,\n        isFocusedLeaf,\n      };\n    }\n\n    if (isLastNode && focusHierarchy.length) {\n      const childId = focusHierarchy[0];\n      const childIndex = node.children.indexOf(childId);\n\n      result[nodeId] = {\n        ...node,\n        ...result[nodeId],\n        prevFocusedChildIndex: node.focusedChildIndex,\n        focusedChildIndex: childIndex,\n      };\n    }\n  }\n\n  for (let i = 0; i < blurHierarchy.length; i++) {\n    const nodeId = blurHierarchy[i];\n    const nodeToUpdate = focusState.nodes[nodeId] as Node;\n\n    // This guards against the situation where a node has been deleted.\n    if (!nodeToUpdate) {\n      continue;\n    }\n\n    result[nodeId] = {\n      ...nodeToUpdate,\n      isFocused: false,\n      isFocusedLeaf: false,\n      prevFocusedChildIndex: nodeToUpdate.focusedChildIndex,\n      focusedChildIndex: null,\n    };\n\n    // Upon navigating out of a grid, its \"saved\" state is reset.\n    if (nodeToUpdate.navigationStyle === 'grid') {\n      // @ts-ignore\n      result[nodeId]._gridColumnIndex = 0;\n      // @ts-ignore\n      result[nodeId]._gridRowIndex = 0;\n    }\n\n    if (nodeToUpdate.trap && !nodeToUpdate.forgetTrapFocusHierarchy) {\n      const childHierarchy = blurHierarchy.slice(i + 1);\n      // @ts-ignore\n      result[nodeId]._focusTrapPreviousHierarchy = childHierarchy;\n    }\n  }\n\n  for (let i = 0; i < focusHierarchy.length; i++) {\n    const nodeId = focusHierarchy[i];\n    const nodeToUpdate = focusState.nodes[nodeId] as Node;\n    const isLeafNode = i === focusHierarchy.length - 1;\n\n    result[nodeId] = {\n      ...nodeToUpdate,\n      isFocused: true,\n      isFocusedLeaf: i === focusHierarchy.length - 1,\n    };\n\n    if (nodeToUpdate.trap) {\n      // @ts-ignore\n      result[nodeId]._focusTrapPreviousHierarchy = [];\n    }\n\n    if (!isLeafNode) {\n      const childId = focusHierarchy[i + 1];\n      const childIndex = nodeToUpdate.children.indexOf(childId);\n\n      // @ts-ignore\n      result[nodeId].prevFocusedChildIndex = nodeToUpdate.focusedChildIndex;\n      // @ts-ignore\n      result[nodeId].focusedChildIndex = childIndex;\n    }\n\n    if (nodeToUpdate.nodeNavigationItem === 'grid-item') {\n      const updatedGridNode = getParentGrid(\n        {\n          ...focusState.nodes,\n          ...result,\n        },\n        result[nodeId] as Node\n      );\n\n      result[updatedGridNode.focusId] = updatedGridNode;\n    }\n  }\n\n  return result;\n}\n","import { Id, NodeMap, Node } from '../types';\n\ntype CallbackName = 'onBlurred' | 'onFocused';\n\nexport default function bubbleEvent({\n  nodeIds,\n  nodes,\n  callbackName,\n  arg,\n}: {\n  nodeIds: Id[];\n  nodes: NodeMap;\n  callbackName: CallbackName;\n  arg: {\n    focusNode: Node | undefined;\n    blurNode: Node | undefined;\n  };\n}) {\n  [...nodeIds].reverse().forEach((targetNodeId) => {\n    const node = nodes[targetNodeId];\n\n    if (!node) {\n      return;\n    }\n\n    const cb = node[callbackName];\n\n    if (typeof cb === 'function') {\n      const argToUse = {\n        ...arg,\n        currentNode: node,\n      };\n\n      cb(argToUse);\n    }\n  });\n}\n","import computeFocusHierarchy from './compute-focus-hierarchy';\nimport getFocusDiff from './get-focus-diff';\nimport getNodesFromFocusChange from './get-nodes-from-focus-change';\nimport emitFocusStateEvents from './emit-focus-state-events';\nimport { FocusState, Id, Orientation } from '../types';\n\ninterface UpdateFocusOptions {\n  focusState: FocusState;\n  assignFocusTo: Id | null | undefined;\n  orientation?: Orientation;\n  preferEnd?: boolean;\n}\n\nexport default function updateFocus({\n  focusState,\n  assignFocusTo,\n  orientation,\n  preferEnd,\n}: UpdateFocusOptions): FocusState {\n  const newFocusHierarchy = computeFocusHierarchy({\n    focusState,\n    assignFocusTo,\n    orientation,\n    preferEnd,\n  });\n\n  const { blur, focus, unchanged } = getFocusDiff({\n    focusHierarchy: newFocusHierarchy,\n    prevFocusHierarchy: focusState.focusHierarchy,\n  });\n\n  const hierarchyHasChanged = blur.length || focus.length;\n\n  if (!hierarchyHasChanged) {\n    return focusState;\n  }\n\n  const newNodes = getNodesFromFocusChange({\n    focusState,\n    blurHierarchy: blur,\n    focusHierarchy: focus,\n    unchangedHierarchy: unchanged,\n  });\n\n  let focusedNodeId: Id;\n  if (focus.length) {\n    focusedNodeId = focus[focus.length - 1];\n  } else {\n    focusedNodeId = unchanged[unchanged.length - 1];\n  }\n\n  const newState: FocusState = {\n    _updatingFocusIsLocked: false,\n    nodes: {\n      ...focusState.nodes,\n      ...newNodes,\n    },\n    focusHierarchy: newFocusHierarchy,\n    focusedNodeId,\n    activeNodeId: focusState.activeNodeId,\n    interactionMode: focusState.interactionMode,\n    _hasPointerEventsEnabled: focusState._hasPointerEventsEnabled,\n  };\n\n  emitFocusStateEvents({\n    focus,\n    blur,\n    focusState: newState,\n  });\n\n  return newState;\n}\n","import { getParents, getChildren } from '../utils/tree-navigation';\nimport { warning } from '../utils/warning';\nimport { FocusState, Id, Orientation, NodeHierarchy, Node } from '../types';\n\ninterface ComputeFocusHierarchyOptions {\n  focusState: FocusState;\n  assignFocusTo: Id | null | undefined;\n  orientation?: Orientation;\n  preferEnd?: boolean;\n}\n\ninterface GenerateFocusHierarchyFromIdOptions {\n  focusState: FocusState;\n  propagateFromId: Id;\n  orientation?: Orientation;\n  preferEnd?: boolean;\n}\n\nfunction generateFocusHierarchyFromId({\n  focusState,\n  propagateFromId,\n  orientation,\n  preferEnd,\n}: GenerateFocusHierarchyFromIdOptions): Id[] {\n  const node = focusState.nodes[propagateFromId] as unknown as Node;\n  let preferredChildren: NodeHierarchy = [];\n  if (node.trap) {\n    preferredChildren = node._focusTrapPreviousHierarchy;\n  }\n\n  return [\n    ...getParents({\n      focusState,\n      nodeId: propagateFromId,\n    }),\n    propagateFromId,\n    ...getChildren({\n      focusState,\n      nodeId: propagateFromId,\n      orientation,\n      preferEnd,\n      preferredChildren,\n    }),\n  ];\n}\n\nexport default function computeFocusHierarchy({\n  focusState,\n  assignFocusTo,\n  orientation,\n  preferEnd,\n}: ComputeFocusHierarchyOptions): Id[] {\n  const explicitlyAssignFocus =\n    typeof assignFocusTo === 'string' &&\n    assignFocusTo !== focusState.focusedNodeId;\n\n  if (explicitlyAssignFocus) {\n    // @ts-ignore\n    const assignedNode = focusState.nodes[assignFocusTo];\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (!assignedNode) {\n        warning(\n          'You attempted to explicitly focus a node that was not found in the focus tree. ' +\n            'This may represent a bug in your application. ' +\n            'You should ensure that a node that matches onMountAssignFocusTo is created and not disabled. ' +\n            'This onMountAssignFocusTo value has been ignored; focus will be computed automatically.',\n          'EXPLICIT_FOCUS_ERROR'\n        );\n      }\n    }\n\n    const focusHierarchy = generateFocusHierarchyFromId({\n      focusState,\n      // @ts-ignore\n      propagateFromId: assignFocusTo,\n      orientation,\n      preferEnd,\n    });\n\n    return focusHierarchy;\n  } else {\n    return generateFocusHierarchyFromId({\n      focusState,\n      propagateFromId: focusState.focusedNodeId,\n      orientation,\n      preferEnd,\n    });\n  }\n}\n","import clamp from './clamp';\nimport nodeCanReceiveIndirectFocus from './node-can-receive-indirect-focus';\nimport { FocusState, Id, NodeHierarchy, Orientation } from '../types';\n\ninterface GetParentsOptions {\n  focusState: FocusState;\n  nodeId: Id;\n  currentFocusHierarchy?: NodeHierarchy;\n}\n\nexport function getParents({\n  focusState,\n  nodeId,\n  currentFocusHierarchy = [],\n}: GetParentsOptions): NodeHierarchy {\n  const node = focusState.nodes[nodeId];\n\n  if (!node) {\n    return [];\n  }\n\n  const parentId = node.parentId;\n\n  if (parentId === null) {\n    return currentFocusHierarchy;\n  } else {\n    return getParents({\n      focusState,\n      nodeId: parentId,\n      currentFocusHierarchy: [parentId, ...currentFocusHierarchy],\n    });\n  }\n}\n\ninterface GetChildrenOptions extends GetParentsOptions {\n  orientation?: Orientation;\n  preferEnd?: boolean;\n  preferredChildren?: NodeHierarchy;\n}\n\nexport function getChildren({\n  focusState,\n  nodeId,\n  currentFocusHierarchy = [],\n  orientation,\n  preferEnd,\n  preferredChildren,\n}: GetChildrenOptions): Id[] {\n  const node = focusState.nodes[nodeId];\n\n  if (!node) {\n    return [];\n  }\n\n  const nodeChildren = node.children.filter((childId) => {\n    const node = focusState.nodes[childId];\n\n    return nodeCanReceiveIndirectFocus(focusState, node);\n  });\n\n  let nextPreferredChildren: NodeHierarchy = [];\n\n  if (nodeChildren.length === 0) {\n    return currentFocusHierarchy;\n  } else {\n    // When the node is a grid, and it has no preferred hierarchy, then we respect the defaultFocusRow/defaultFocusColumn\n    // attributes. Preferred children represent a focus trap.\n    if (\n      node.navigationStyle === 'grid' &&\n      (!preferredChildren || preferredChildren.length === 0)\n    ) {\n      const preferredRowIndex = node.defaultFocusRow ?? 0;\n      const rowIndex = clamp(preferredRowIndex, 0, node.children.length - 1);\n      const rowId = node.children[rowIndex];\n\n      const row = focusState.nodes[rowId];\n\n      if (!row || row.children.length === 0) {\n        return [...currentFocusHierarchy, rowId];\n      }\n\n      const preferredColumnIndex = node.defaultFocusColumn ?? 0;\n      const columnIndex = clamp(\n        preferredColumnIndex,\n        0,\n        row.children.length - 1\n      );\n      const columnId = row.children[columnIndex];\n\n      return getChildren({\n        focusState,\n        nodeId: columnId,\n        currentFocusHierarchy: [...currentFocusHierarchy, rowId, columnId],\n        preferredChildren: [],\n      });\n    }\n\n    let nextChildId = nodeChildren[0];\n    const numericdefaultFocusChild =\n      typeof node.defaultFocusChild === 'number' &&\n      Number.isFinite(node.defaultFocusChild);\n    const isValiddefaultFocusChild =\n      numericdefaultFocusChild || typeof node.defaultFocusChild === 'function';\n\n    // If the dev explicitly defined an explicit index, then we always use that.\n    if (isValiddefaultFocusChild && node.navigationStyle !== 'grid') {\n      let childIndex = 0;\n      if (numericdefaultFocusChild) {\n        // @ts-ignore\n        childIndex = node.defaultFocusChild;\n      } else {\n        // @ts-ignore\n        childIndex = node.defaultFocusChild();\n      }\n\n      if (typeof childIndex === 'number' && Number.isFinite(childIndex)) {\n        const maxChildIndex = Math.max(0, nodeChildren.length - 1);\n        childIndex = clamp(childIndex, 0, maxChildIndex);\n        nextChildId = nodeChildren[childIndex];\n      } else {\n        nextChildId = nodeChildren[0];\n      }\n    }\n\n    // Otherwise, there are situations where we choose a child other than the\n    // first.\n    else {\n      // `preferredChildren` exist currently when restoring a focus trap's hierarchy\n      if (preferredChildren && preferredChildren.length) {\n        const possibleId = preferredChildren[0];\n\n        if (focusState.nodes[possibleId]) {\n          nextChildId = possibleId;\n          nextPreferredChildren = preferredChildren.slice(1);\n        }\n      }\n\n      // This allows the focus index to restore to the index in\n      // the \"direction\" of motion. It's not incredibly common, but not so\n      // rare that it's an edge case.\n      if (orientation && orientation === node.orientation) {\n        // TODO: leaving this here in the event that I refactor the\n        // preferred column/row implementation above, even though\n        // it is currently redundant.\n        // @ts-ignore\n        const isGridNavigation = node.navigationStyle === 'grid';\n        const useLastNode = !isGridNavigation && preferEnd;\n\n        const lastIndex = Math.max(0, nodeChildren.length - 1);\n        const index = useLastNode ? lastIndex : 0;\n        nextChildId = nodeChildren[index];\n      }\n    }\n\n    return getChildren({\n      focusState,\n      nodeId: nextChildId,\n      currentFocusHierarchy: [...currentFocusHierarchy, nextChildId],\n      preferredChildren: nextPreferredChildren,\n    });\n  }\n}\n","import { NodeHierarchy } from '../types';\n\ninterface GetFocusDiffOptions {\n  focusHierarchy: NodeHierarchy;\n  prevFocusHierarchy: NodeHierarchy;\n}\n\ninterface FocusDiff {\n  blur: NodeHierarchy;\n  focus: NodeHierarchy;\n  unchanged: NodeHierarchy;\n}\n\nexport default function getFocusDiff({\n  focusHierarchy = [],\n  prevFocusHierarchy = [],\n}: GetFocusDiffOptions): FocusDiff {\n  const largerIndex = Math.max(\n    focusHierarchy.length,\n    prevFocusHierarchy.length\n  );\n\n  let splitIndex = NaN;\n  for (let index = 0; index < largerIndex; index++) {\n    const prevId = prevFocusHierarchy[index];\n    const currentId = focusHierarchy[index];\n\n    if (prevId !== currentId) {\n      splitIndex = index;\n      break;\n    }\n  }\n\n  if (Number.isNaN(splitIndex)) {\n    return {\n      blur: [],\n      focus: [],\n      unchanged: prevFocusHierarchy,\n    };\n  }\n\n  const unchanged = prevFocusHierarchy.slice(0, splitIndex);\n  const blur = prevFocusHierarchy.slice(splitIndex);\n  const focus = focusHierarchy.slice(splitIndex);\n\n  return {\n    blur,\n    focus,\n    unchanged,\n  };\n}\n","import { NodeHierarchy, FocusState } from '../types';\nimport bubbleEvent from './bubble-focus-event';\n\nexport default function emitFocusStateEvents({\n  focus,\n  blur,\n  focusState,\n}: {\n  focus: NodeHierarchy;\n  blur: NodeHierarchy;\n  focusState: FocusState;\n}): void {\n  const blurNodeId = blur.slice(-1)[0];\n  const focusNodeId = focus.slice(-1)[0];\n\n  const blurNode =\n    typeof blurNodeId !== 'undefined'\n      ? focusState.nodes[blurNodeId]\n      : undefined;\n  const focusNode =\n    typeof focusNodeId !== 'undefined'\n      ? focusState.nodes[focusNodeId]\n      : undefined;\n\n  bubbleEvent({\n    nodeIds: blur,\n    nodes: focusState.nodes,\n    callbackName: 'onBlurred',\n    arg: {\n      blurNode,\n      focusNode,\n    },\n  });\n\n  bubbleEvent({\n    nodeIds: focus,\n    nodes: focusState.nodes,\n    callbackName: 'onFocused',\n    arg: {\n      blurNode,\n      focusNode,\n    },\n  });\n}\n","import { FocusState, Node, Id } from '../../types';\n\ninterface GetGridParent {\n  focusState: FocusState;\n  focusedNode: Node;\n}\n\ninterface GetGridParentReturn {\n  gridNode: Node;\n  rowNode: Node;\n}\n\nexport default function getGridParent({\n  focusState,\n  focusedNode,\n}: GetGridParent): GetGridParentReturn | null {\n  if (focusedNode.nodeNavigationItem === 'grid-item') {\n    const rowNodeId = focusedNode.parentId as Id;\n    const rowNode = focusState.nodes[rowNodeId];\n\n    if (!rowNode) {\n      return null;\n    }\n\n    const gridNodeId = rowNode.parentId as Id;\n    const gridNode = focusState.nodes[gridNodeId];\n\n    if (!gridNode) {\n      return null;\n    }\n\n    return {\n      gridNode,\n      rowNode,\n    };\n  } else if (focusedNode.nodeNavigationItem === 'grid-row') {\n    const gridNodeId = focusedNode.parentId as Id;\n    const gridNode = focusState.nodes[gridNodeId];\n\n    if (!gridNode) {\n      return null;\n    }\n\n    return {\n      gridNode,\n      rowNode: focusedNode,\n    };\n  }\n\n  return null;\n}\n","import { FocusStore, Node, Arrow, LRUDKey, LRUDFocusEvents } from '../types';\n\ntype FocusCallbackNames = keyof LRUDFocusEvents;\ntype PreventDefault = () => void;\ntype StopPropagation = () => void;\n\nfunction executeFunction(\n  node: Node,\n  fn: FocusCallbackNames,\n  {\n    isArrow,\n    key,\n    targetNode,\n    preventDefault,\n    stopPropagation,\n  }: {\n    isArrow: boolean;\n    key: LRUDKey;\n    targetNode: Node;\n    preventDefault: PreventDefault;\n    stopPropagation: StopPropagation;\n  }\n) {\n  const cb = node[fn];\n\n  if (typeof cb === 'function') {\n    const arg = {\n      isArrow,\n      key,\n      node,\n      stopPropagation,\n      preventDefault,\n      targetNode,\n    };\n    cb(arg);\n  }\n}\n\nexport default function bubbleKey(focusTree: FocusStore, key: LRUDKey) {\n  const state = focusTree.getState();\n  const { focusHierarchy } = state;\n\n  const isArrow =\n    key === 'up' || key === 'down' || key === 'right' || key === 'left';\n  const isSelect = key === 'select';\n  const isBack = key === 'back';\n\n  let defaultPrevented = false;\n  let propagationStopped = false;\n\n  const reverseFocusHierarchy = focusHierarchy.slice().reverse();\n  if (reverseFocusHierarchy.length) {\n    // @ts-ignore\n    function preventDefault() {\n      defaultPrevented = true;\n    }\n\n    // @ts-ignore\n    function stopPropagation() {\n      propagationStopped = true;\n    }\n\n    const targetNodeId = reverseFocusHierarchy[0];\n\n    // This is the equivalent of event.target within DOM events.\n    const targetNode: Node = state.nodes[targetNodeId] as Node;\n\n    reverseFocusHierarchy.forEach((focusedNodeId) => {\n      if (propagationStopped) {\n        return;\n      }\n\n      const node = state.nodes[focusedNodeId];\n\n      if (!node) {\n        return;\n      }\n\n      executeFunction(node, 'onKey', {\n        isArrow,\n        key,\n        targetNode,\n        preventDefault,\n        stopPropagation,\n      });\n\n      if (isArrow) {\n        executeFunction(node, 'onArrow', {\n          isArrow,\n          key,\n          targetNode,\n          preventDefault,\n          stopPropagation,\n        });\n      }\n\n      if (key === 'left') {\n        executeFunction(node, 'onLeft', {\n          isArrow,\n          key,\n          targetNode,\n          preventDefault,\n          stopPropagation,\n        });\n      }\n\n      if (key === 'right') {\n        executeFunction(node, 'onRight', {\n          isArrow,\n          key,\n          targetNode,\n          preventDefault,\n          stopPropagation,\n        });\n      }\n\n      if (key === 'up') {\n        executeFunction(node, 'onUp', {\n          isArrow,\n          key,\n          targetNode,\n          preventDefault,\n          stopPropagation,\n        });\n      }\n\n      if (key === 'down') {\n        executeFunction(node, 'onDown', {\n          isArrow,\n          key,\n          targetNode,\n          preventDefault,\n          stopPropagation,\n        });\n      }\n\n      if (isSelect) {\n        executeFunction(node, 'onSelected', {\n          isArrow,\n          key,\n          targetNode,\n          stopPropagation,\n          preventDefault: () => {},\n        });\n      }\n\n      if (isBack) {\n        executeFunction(node, 'onBack', {\n          isArrow,\n          key,\n          targetNode,\n          stopPropagation,\n          preventDefault: () => {},\n        });\n      }\n    });\n  }\n\n  if (isArrow && !defaultPrevented) {\n    /* This cast is, for some reason, required for TSDX */\n    focusTree.handleArrow(key as Arrow);\n  } else if (isSelect && !defaultPrevented) {\n    focusTree.handleSelect();\n  }\n}\n","import createNode from './utils/create-node';\nimport deleteNodeUtil from './utils/delete-node';\nimport updateFocus from './update-focus/update-focus';\nimport handleArrowUtil from './handle-arrow/handle-arrow';\nimport enforceStateStructure from './utils/enforce-state-structure';\nimport recursivelyUpdateChildren from './utils/recursively-update-node';\nimport bubbleKey from './utils/bubble-key-input';\nimport { warning } from './utils/warning';\nimport {\n  FocusState,\n  Orientation,\n  Node,\n  Id,\n  NavigationStyle,\n  Arrow,\n  FocusStore,\n  NodeUpdate,\n  Listener,\n  NodeDefinition,\n  InteractionMode,\n  LRUDKey,\n} from './types';\n\ninterface CreateFocusStoreOptions {\n  orientation?: Orientation;\n  wrapping?: boolean;\n  navigationStyle?: NavigationStyle;\n  pointerEvents?: boolean;\n}\n\n// When these props of a node change, then the store\n// will alert subscribers.\nconst dynamicNodeProps = [\n  'defaultFocusChild',\n  'disabled',\n  'isExiting',\n  'defaultFocusColumn',\n  'defaultFocusRow',\n  'wrapping',\n  'trap',\n  'forgetTrapFocusHierarchy',\n];\n\nexport default function createFocusStore({\n  orientation = 'horizontal',\n  wrapping = false,\n  pointerEvents = false,\n}: CreateFocusStoreOptions = {}): FocusStore {\n  let currentState: FocusState = {\n    focusedNodeId: 'root',\n    activeNodeId: null,\n    focusHierarchy: ['root'],\n\n    // TODO: should the interaction state values be moved out of the state and placed\n    // on the store directly?\n    interactionMode: 'lrud',\n    _hasPointerEventsEnabled: pointerEvents,\n\n    _updatingFocusIsLocked: false,\n    nodes: {\n      root: {\n        // Note: this a \"fake\" React ref in that React isn't ensuring\n        // that it stays constant.\n        elRef: {\n          current: null,\n        },\n        focusId: 'root',\n        isRoot: true,\n        parentId: null,\n        active: false,\n        isExiting: false,\n        isFocused: true,\n        isFocusedLeaf: true,\n        trap: false,\n        disabled: false,\n        defaultFocusColumn: 0,\n        defaultFocusRow: 0,\n        orientation,\n        wrapping,\n        navigationStyle: 'first-child',\n        nodeNavigationItem: 'default',\n        forgetTrapFocusHierarchy: true,\n        children: [],\n        focusedChildIndex: null,\n        prevFocusedChildIndex: null,\n        _gridColumnIndex: null,\n        _gridRowIndex: null,\n        wrapGridVertical: false,\n        wrapGridHorizontal: false,\n        _focusTrapPreviousHierarchy: [],\n      },\n    },\n  };\n\n  let listeners: Listener[] = [];\n  function subscribe(listener: Listener) {\n    listeners.push(listener);\n    let subscribed = true;\n\n    return function unsubscribe() {\n      if (!subscribed) {\n        return;\n      }\n\n      subscribed = false;\n\n      const index = listeners.indexOf(listener);\n      listeners.splice(index, 1);\n    };\n  }\n\n  function onUpdate() {\n    for (let i = 0; i < listeners.length; i++) {\n      const listener = listeners[i];\n      listener();\n    }\n  }\n\n  function createNodes(\n    nodeHierarchy: Node[],\n    nodeDefinitionHierarchy: NodeDefinition[]\n  ) {\n    const { nodes, assignFocusTo, shouldLockFocus } = createNode({\n      focusState: currentState,\n      nodeHierarchy,\n      nodeDefinitionHierarchy,\n    });\n\n    if (shouldLockFocus) {\n      currentState._updatingFocusIsLocked = shouldLockFocus;\n    }\n\n    const hasNodesToUpdate = Boolean(nodes);\n    const isUnlockingFocus =\n      !shouldLockFocus && currentState._updatingFocusIsLocked;\n\n    if (hasNodesToUpdate || isUnlockingFocus) {\n      let possibleNewState = {\n        ...currentState,\n        nodes: {\n          ...currentState.nodes,\n          ...nodes,\n        },\n      };\n\n      // When the focus is locked, we \"silently\" update the state. We may be adding new nodes and so on,\n      // but the tree's focus state is not being updated.\n      if (shouldLockFocus) {\n        currentState = {\n          ...possibleNewState,\n          _updatingFocusIsLocked: true,\n        };\n      } else {\n        const nodeHierarchyIds = nodeHierarchy.map((node) => node.focusId);\n\n        const focusedItemIndex = nodeHierarchyIds.indexOf(\n          currentState.focusedNodeId\n        );\n\n        const assigningFocusOnMount = nodeDefinitionHierarchy.findIndex(\n          (v) => v.onMountAssignFocusTo\n        );\n\n        let updatedFocusState = possibleNewState;\n        if (focusedItemIndex > -1 || assigningFocusOnMount > -1) {\n          updatedFocusState = updateFocus({\n            focusState: possibleNewState,\n            assignFocusTo,\n          });\n        }\n\n        if (updatedFocusState !== currentState) {\n          currentState = updatedFocusState;\n          onUpdate();\n        }\n      }\n    }\n  }\n\n  function deleteNode(nodeId: Id): void {\n    const newState = deleteNodeUtil({\n      focusState: currentState,\n      nodeId,\n    });\n\n    if (newState && newState !== currentState) {\n      currentState = newState;\n      onUpdate();\n    }\n  }\n\n  function setFocus(nodeId: Id): void {\n    const currentNode = currentState.nodes[nodeId];\n\n    if (!currentNode) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (typeof nodeId !== 'string') {\n          warning(\n            `You called setFocus with a node ID that is not a string. The node ID that you passed was: ${nodeId}. All node IDs are strings.`,\n            'NODE_ID_NOT_STRING_TO_SET_FOCUS'\n          );\n        } else {\n          warning(\n            'You attempted to set focus to a node that does not exist in the focus tree.',\n            'NODE_DOES_NOT_EXIST'\n          );\n        }\n      }\n\n      return;\n    } else if (currentNode.disabled) {\n      return;\n    } else if (currentNode.isExiting) {\n      if (process.env.NODE_ENV !== 'production') {\n        warning(\n          'You attempted to set focus to a node that is exiting. This has no effect, but it may represent a memory leak in your application.',\n          'FOCUS_SET_TO_EXITING_NODE'\n        );\n      }\n      return;\n    }\n\n    const updatedFocusState = updateFocus({\n      focusState: currentState,\n      assignFocusTo: nodeId,\n    });\n\n    if (updatedFocusState !== currentState) {\n      currentState = updatedFocusState;\n\n      onUpdate();\n    }\n  }\n\n  function getState(): FocusState {\n    return currentState;\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    subscribe(() => {\n      enforceStateStructure(currentState);\n    });\n  }\n\n  function setInteractionMode(newMode: InteractionMode) {\n    if (newMode === currentState.interactionMode) {\n      return;\n    }\n\n    const newFocusState: FocusState = {\n      ...currentState,\n      interactionMode: newMode,\n    };\n\n    currentState = newFocusState;\n  }\n\n  function updateNode(nodeId: Id, update: NodeUpdate) {\n    const currentNode = currentState.nodes[nodeId];\n\n    if (!currentNode) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (update.disabled) {\n          warning(\n            'You attempted to disable a node that does not exist in the focus tree. ' +\n              'This has no effect, but it may represent an error in your code.',\n            'DISABLE_NODE_THAT_DOES_NOT_EXIST'\n          );\n        }\n\n        if (update.isExiting) {\n          warning(\n            'You attempted to exit a node that does not exist in the focus tree. ' +\n              'This has no effect, but it may represent an error in your code.',\n            'EXIT_NODE_THAT_DOES_NOT_EXIST'\n          );\n        }\n      }\n\n      return;\n    }\n\n    if (nodeId === 'root') {\n      if (process.env.NODE_ENV !== 'production') {\n        if (update.disabled) {\n          warning(\n            'You attempted to disable the root node. ' +\n              'The root node of a focus tree cannot be disabled. ' +\n              'This has no effect, but it may represent an error in your code.',\n            'DISABLE_ROOT_NODE'\n          );\n        }\n\n        if (update.isExiting) {\n          warning(\n            'You attempted to exit the root node. ' +\n              'The root node of a focus tree cannot be exited. ' +\n              'This has no effect, but it may represent an error in your code.',\n            'EXIT_ROOT_NODE'\n          );\n        }\n      }\n      return;\n    }\n\n    const updateHasDisabled = update.disabled !== undefined;\n    const updateHasExiting = update.isExiting !== undefined;\n\n    if (updateHasDisabled) {\n      update.disabled = Boolean(update.disabled);\n    }\n\n    if (updateHasExiting) {\n      update.isExiting = Boolean(update.isExiting);\n    }\n\n    const nodeChanged = dynamicNodeProps.some((prop) => {\n      // @ts-ignore\n      const updateValue = update[prop];\n      const updateValueExists = updateValue !== undefined;\n\n      // @ts-ignore\n      return updateValueExists && currentNode[prop] !== update[prop];\n    });\n\n    if (update && nodeChanged) {\n      const newNode: Node = {\n        ...currentNode,\n        disabled: update.disabled ?? currentNode.disabled,\n        isExiting: update.isExiting ?? currentNode.isExiting,\n        defaultFocusColumn:\n          update.defaultFocusColumn ?? currentNode.defaultFocusColumn,\n        defaultFocusRow: update.defaultFocusRow ?? currentNode.defaultFocusRow,\n        wrapping: update.wrapping ?? currentNode.wrapping,\n        trap: update.trap ?? currentNode.trap,\n        forgetTrapFocusHierarchy:\n          update.forgetTrapFocusHierarchy ??\n          currentNode.forgetTrapFocusHierarchy,\n        defaultFocusChild:\n          update.defaultFocusChild ?? currentNode.defaultFocusChild,\n      };\n\n      let updatedChildren = {};\n\n      if (updateHasExiting || updateHasDisabled) {\n        let recursiveUpdate: NodeUpdate = {};\n        if (updateHasDisabled) {\n          recursiveUpdate.disabled = update.disabled;\n        }\n        if (updateHasExiting) {\n          recursiveUpdate.isExiting = update.isExiting;\n        }\n\n        updatedChildren = recursivelyUpdateChildren(\n          currentState.nodes,\n          newNode.children,\n          // Note: we don't pass the full update as the other attributes (trap, wrapping, etc)\n          // only affect the parent, whereas these specific values affect the children.\n          recursiveUpdate\n        );\n      }\n\n      const nodeWasFocused = currentState.focusHierarchy.find(\n        (v) => v === nodeId\n      );\n\n      let updatedState = {\n        ...currentState,\n        nodes: {\n          ...currentState.nodes,\n          ...updatedChildren,\n          [nodeId]: newNode,\n        },\n      };\n\n      // Only do this if the update actually updated these\n      if (nodeWasFocused && (updateHasDisabled || updateHasExiting)) {\n        const parentId = newNode.parentId as Id;\n\n        updatedState = updateFocus({\n          focusState: updatedState,\n          assignFocusTo: parentId,\n        });\n      }\n\n      currentState = updatedState;\n      onUpdate();\n    }\n  }\n\n  function handleArrow(arrow: Arrow) {\n    const newState = handleArrowUtil({\n      focusState: currentState,\n      arrow,\n    });\n\n    if (!newState) {\n      return;\n    }\n\n    if (newState.interactionMode !== 'lrud') {\n      newState.interactionMode = 'lrud';\n    }\n\n    if (newState !== currentState) {\n      currentState = newState;\n      onUpdate();\n    }\n  }\n\n  function handleSelect(focusId?: string) {\n    const leafNodeId =\n      typeof focusId === 'string'\n        ? focusId\n        : currentState.focusHierarchy[currentState.focusHierarchy.length - 1];\n    const leafNode = currentState.nodes[leafNodeId];\n\n    if (leafNodeId === currentState.activeNodeId) {\n      return;\n    }\n\n    if (!leafNode) {\n      return;\n    }\n\n    const newNode: Node = {\n      ...leafNode,\n      active: true,\n    };\n\n    const newNodes = {\n      [leafNodeId]: newNode,\n    };\n\n    if (currentState.activeNodeId) {\n      const previousActiveNode = currentState.nodes[currentState.activeNodeId];\n\n      if (previousActiveNode) {\n        newNodes[currentState.activeNodeId] = {\n          ...previousActiveNode,\n          active: false,\n        };\n      }\n    }\n\n    const updatedState = {\n      ...currentState,\n      activeNodeId: leafNodeId,\n      nodes: {\n        ...currentState.nodes,\n        ...newNodes,\n      },\n    };\n\n    currentState = updatedState;\n    onUpdate();\n  }\n\n  // This boolean tracks whether or not we have registered our pointer listeners.\n  // This ensures that we never register those listeners more than once.\n  let isListeningToPointerEvents = false;\n\n  // This allows a user to dynamically enable/disable pointer events.\n  function configurePointerEvents(enablePointerEvents: boolean) {\n    const existingState = currentState;\n\n    currentState = {\n      ...existingState,\n      _hasPointerEventsEnabled: enablePointerEvents,\n    };\n\n    if (enablePointerEvents && !isListeningToPointerEvents) {\n      addPointerListeners();\n    }\n\n    if (!enablePointerEvents) {\n      removePointerListeners();\n    }\n  }\n\n  let handlingPointerEvent = false;\n  function onPointerEvent() {\n    if (handlingPointerEvent) {\n      return;\n    }\n\n    handlingPointerEvent = true;\n    requestAnimationFrame(() => {\n      setInteractionMode('pointer');\n      handlingPointerEvent = false;\n    });\n  }\n\n  function addPointerListeners() {\n    isListeningToPointerEvents = true;\n    window.addEventListener('mousemove', onPointerEvent);\n    window.addEventListener('mousedown', onPointerEvent);\n  }\n\n  function removePointerListeners() {\n    isListeningToPointerEvents = false;\n    window.removeEventListener('mousemove', onPointerEvent);\n    window.removeEventListener('mousedown', onPointerEvent);\n  }\n\n  function destroy() {\n    removePointerListeners();\n  }\n\n  if (pointerEvents) {\n    addPointerListeners();\n  }\n\n  function internalProcessKey(key: LRUDKey) {\n    bubbleKey(_focusStore, key);\n  }\n\n  const _focusStore: FocusStore = {\n    subscribe,\n    getState,\n    createNodes,\n    deleteNode,\n    setFocus,\n    updateNode,\n    handleArrow,\n    handleSelect,\n    configurePointerEvents,\n    destroy,\n    processKey: {\n      select: () => internalProcessKey('select'),\n      back: () => internalProcessKey('back'),\n      down: () => internalProcessKey('down'),\n      left: () => internalProcessKey('left'),\n      right: () => internalProcessKey('right'),\n      up: () => internalProcessKey('up'),\n    },\n  };\n\n  return _focusStore;\n}\n","// This maps a Key string, returned from an event, to a handler name.\nexport default {\n  ArrowUp: 'up',\n  ArrowDown: 'down',\n  ArrowLeft: 'left',\n  ArrowRight: 'right',\n  Enter: 'select',\n  Escape: 'back',\n};\n","import React, { useState, useEffect, useRef } from 'react';\nimport createFocusStore from './focus-store';\nimport lrudInput from './lrud-input/focus-lrud';\nimport { ProviderValue, RootFocusNode, Orientation } from './types';\nimport { warning } from './utils/warning';\n\nconst FocusContext = React.createContext<null | ProviderValue>(null);\n\nfunction FocusRoot({\n  orientation,\n  wrapping,\n  children,\n  pointerEvents,\n  throttle = 0\n}: {\n  children?: React.ReactNode;\n  orientation?: Orientation;\n  wrapping?: boolean;\n  pointerEvents?: boolean;\n  throttle?:number\n}) {\n  const rootElRef = useRef(null);\n  const [providerValue] = useState<ProviderValue>(() => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (\n        orientation !== undefined &&\n        orientation !== 'vertical' &&\n        orientation !== 'horizontal'\n      ) {\n        warning(\n          'An invalid orientation was passed to the FocusRoot. The orientation must either be \"vertical\" or \"horizontal.\"',\n          'INVALID_ROOT_ORIENTATION'\n        );\n      }\n    }\n\n    const store = createFocusStore({\n      orientation,\n      wrapping,\n      pointerEvents,\n    });\n\n    return {\n      store,\n      focusDefinitionHierarchy: [\n        {\n          elRef: rootElRef,\n          focusId: 'root',\n        },\n      ],\n      focusNodesHierarchy: [store.getState().nodes.root as RootFocusNode],\n    };\n  });\n\n  useEffect(() => {\n    const lrud = lrudInput(providerValue.store);\n    const unsubscribe = lrud.subscribe(throttle);\n    return () => {\n      unsubscribe();\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  return (\n    <FocusContext.Provider value={providerValue}>\n      {children}\n    </FocusContext.Provider>\n  );\n}\n\nexport default {\n  Context: FocusContext,\n  FocusRoot,\n};\n","import { warning } from '../utils/warning';\nimport { NodeDefinition, FocusState, NodeMap, Id, Node } from '../types';\nimport getIndex from './get-index';\n\ninterface createNodeDefinitionHierarchyState {\n  focusState: FocusState;\n  nodeDefinitionHierarchy: NodeDefinition[];\n  nodeHierarchy: Node[];\n}\n\ninterface createNodeDefinitionHierarchyReturn {\n  nodes: NodeMap | null;\n  assignFocusTo: Id | null;\n  shouldLockFocus: boolean;\n}\n\nexport default function createNodeDefinitionHierarchy({\n  focusState,\n  nodeDefinitionHierarchy,\n  nodeHierarchy,\n}: createNodeDefinitionHierarchyState): createNodeDefinitionHierarchyReturn {\n  const nodeUpdates: NodeMap = {};\n\n  let onMountAssignFocusToReturn: Id | null = null;\n  let onMountAssignFocusTo: Id | null = null;\n  let shouldLockFocus = focusState._updatingFocusIsLocked;\n\n  for (let i = 0; i < nodeDefinitionHierarchy.length; i++) {\n    const node = nodeHierarchy[i];\n    const isLastNode = i === nodeDefinitionHierarchy.length - 1;\n\n    const nodeDefinition = nodeDefinitionHierarchy[i];\n    const currentNode = focusState.nodes[nodeDefinition.focusId];\n    const isCreatingNewNode = !currentNode;\n\n    if (nodeDefinition.onMountAssignFocusTo !== undefined) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (onMountAssignFocusTo !== null) {\n          warning(\n            '[Focus]: More than one onMountAssignFocusTo was encountered while creating a new focus subtree. This may represent an error in your code. ' +\n              'We strongly encourage you to ensure that only a single node is assigned an onMountAssignFocusTo when creating a focus subtree. ' +\n              'Your onMountAssignFocusTo has been ignored, and the first child will be assigned focus.',\n            'MORE_THAN_ONE_ONMOUNTFOCUS'\n          );\n        }\n      }\n\n      onMountAssignFocusTo = nodeDefinition.onMountAssignFocusTo;\n\n      // We only actually assign the focus when this thing happens\n      if (isLastNode) {\n        // We disable the focus lock whenever we \"apply\" an `onMountAssignFocusTo`\n        shouldLockFocus = false;\n        onMountAssignFocusToReturn = nodeDefinition.onMountAssignFocusTo;\n      } else {\n        shouldLockFocus = true;\n      }\n    }\n\n    if (\n      nodeDefinition.navigationStyle === 'grid' &&\n      (nodeDefinition.defaultFocusColumn || nodeDefinition.defaultFocusRow)\n    ) {\n      if (isLastNode) {\n        shouldLockFocus = false;\n        const gridNode = focusState.nodes[node.focusId];\n\n        if (gridNode) {\n          const rowIndex = getIndex(\n            gridNode.children.length,\n            nodeDefinition.defaultFocusRow ?? 0,\n            gridNode.wrapGridVertical\n          );\n\n          const newRowNodeId = gridNode.children[rowIndex];\n          const rowNode = focusState.nodes[newRowNodeId];\n\n          // TODO: fix this\n          const rowNodeChildrenLength = rowNode?.children?.length ?? 0;\n\n          const columnIndex = getIndex(\n            rowNodeChildrenLength,\n            nodeDefinition.defaultFocusColumn ?? 0,\n            gridNode.wrapGridHorizontal\n          );\n\n          const itemIndex = Math.min(\n            columnIndex,\n            Math.max(rowNodeChildrenLength - 1, 0)\n          );\n          const focusedItemId = rowNode?.children[itemIndex];\n\n          if (focusedItemId) {\n            onMountAssignFocusToReturn = focusedItemId;\n          }\n        }\n      } else {\n        shouldLockFocus = true;\n        // TODO: warn. This is likely a bug.\n      }\n    }\n\n    // If we already have the node, then there is nothing else to do, so we bail\n    // (after checking for errors)\n    if (!isCreatingNewNode) {\n      // NOTE: this check *requires* that this API follow the `useEffect` order of React.\n      // The implementation of this feature ties this library very tightly with React.\n      const isFinalNode = i === nodeDefinitionHierarchy.length - 1;\n      const setFocusGoal = nodeDefinition.onMountAssignFocusTo;\n      if (process.env.NODE_ENV !== 'production') {\n        if (isFinalNode && setFocusGoal && !focusState.nodes[setFocusGoal]) {\n          warning(\n            'You configured an onMountAssignFocusTo that was not found in the focus tree. This may represent an error in your application. ' +\n              'Please make sure that the node specified by onMountAssignFocusTo is created at the same time as the parent.',\n            'NOT_FOUND_ON_MOUNT_FOCUS'\n          );\n        }\n      }\n\n      continue;\n    }\n\n    const parentLoopIndex = i - 1;\n    const parentDefinition = nodeDefinitionHierarchy[parentLoopIndex];\n    const parentId = parentDefinition.focusId;\n\n    const parentNode = (focusState.nodes[parentId] ||\n      nodeUpdates[parentId]) as unknown as Node;\n\n    const parentChildren = parentNode.children;\n\n    const newParentChildren = Array.isArray(parentChildren)\n      ? parentChildren.concat(nodeDefinition.focusId)\n      : [nodeDefinition.focusId];\n\n    nodeUpdates[parentId] = {\n      ...parentNode,\n      children: newParentChildren,\n    };\n\n    nodeUpdates[nodeDefinition.focusId] = node;\n  }\n\n  return {\n    nodes: Object.keys(nodeUpdates).length ? nodeUpdates : null,\n    assignFocusTo: onMountAssignFocusToReturn,\n    shouldLockFocus,\n  };\n}\n","import nodeIdIsFocused from './node-id-is-focused';\nimport { warning } from './warning';\nimport updateFocus from '../update-focus/update-focus';\nimport { FocusState, Id, NodeMap, Node } from '../types';\n\nfunction recursivelyDeleteChildren(nodes: NodeMap, children: Id[]) {\n  children.forEach((childId) => {\n    const childNode = nodes[childId];\n    const childChildren = childNode ? childNode.children : null;\n\n    delete nodes[childId];\n\n    if (Array.isArray(childChildren)) {\n      recursivelyDeleteChildren(nodes, childChildren);\n    }\n  });\n}\n\nexport default function deleteNode({\n  focusState,\n  nodeId,\n}: {\n  focusState: FocusState;\n  nodeId: Id;\n}): FocusState | null {\n  const node = focusState.nodes[nodeId];\n\n  if (!node) {\n    return null;\n  }\n\n  if (nodeId === 'root') {\n    if (process.env.NODE_ENV !== 'production') {\n      warning(\n        'You attempted to delete the root node. ' +\n          'The root node of a focus tree cannot be deleted. ' +\n          'The focus tree has not been changed;',\n        'ATTEMPTED_TO_DELETE_ROOT'\n      );\n    }\n\n    return null;\n  }\n\n  const parentId = node.parentId;\n\n  // TODO: use type guards to type this away\n  if (!parentId) {\n    return null;\n  }\n\n  const parentNode = focusState.nodes[parentId] as Node;\n\n  let newParentChildren: Id[] = [];\n  if (parentNode.children.length > 1) {\n    newParentChildren = parentNode.children.filter((id) => id !== nodeId);\n  }\n\n  const newNodes: NodeMap = {\n    ...focusState.nodes,\n    [parentId]: {\n      ...parentNode,\n      children: newParentChildren,\n    },\n  };\n\n  delete newNodes[nodeId];\n\n  recursivelyDeleteChildren(newNodes, node.children);\n\n  let stateAfterDeletion = {\n    ...focusState,\n    nodes: newNodes,\n  };\n\n  const nodeWasFocused = nodeIdIsFocused(focusState.focusHierarchy, nodeId);\n\n  if (nodeWasFocused) {\n    stateAfterDeletion = updateFocus({\n      focusState: stateAfterDeletion,\n      assignFocusTo: parentId,\n    });\n  }\n\n  return stateAfterDeletion;\n}\n","import { NodeHierarchy, Id } from '../types';\n\nexport default function nodeIdIsFocused(\n  focusHierarchy: NodeHierarchy,\n  nodeId: Id\n) {\n  const idIndex = focusHierarchy.indexOf(nodeId);\n  return idIndex !== -1;\n}\n","import { Id, NodeMap, NodeUpdate } from '../types';\n\nexport default function recursivelyUpdateChildren(\n  nodes: NodeMap,\n  children: Id[],\n  update: NodeUpdate\n): NodeMap {\n  let newNodes: NodeMap = {};\n\n  children.forEach(childId => {\n    const childNode = nodes[childId];\n\n    if (!childNode) {\n      return;\n    }\n\n    const childChildren = childNode ? childNode.children : null;\n\n    newNodes[childNode.focusId] = {\n      ...childNode,\n      ...update,\n    };\n\n    if (Array.isArray(childChildren)) {\n      const updatedChildrenNodes = recursivelyUpdateChildren(\n        nodes,\n        childChildren,\n        update\n      );\n      newNodes = {\n        ...newNodes,\n        ...updatedChildrenNodes,\n      };\n    }\n  });\n\n  return newNodes;\n}\n","import defaultNavigation from './default-navigation/default-navigation';\nimport gridNavigation from './grid-navigation/grid-navigation';\nimport determineNavigationStyle from './determine-navigation-style/determine-navigation-style';\nimport { FocusState, Arrow, Orientation, Direction } from '../types';\n\ninterface HandleArrowOptions {\n  focusState: FocusState;\n  arrow: Arrow;\n}\n\nexport default function handleArrow({\n  focusState,\n  arrow,\n}: HandleArrowOptions): FocusState | null {\n  const orientation: Orientation =\n    arrow === 'right' || arrow === 'left' ? 'horizontal' : 'vertical';\n  const direction: Direction =\n    arrow === 'down' || arrow === 'right' ? 'forward' : 'backward';\n\n  const focusedNode = focusState.nodes[focusState.focusedNodeId];\n\n  if (!focusedNode) {\n    return null;\n  }\n\n  const navigationStyle = determineNavigationStyle({\n    arrow,\n    focusState,\n    focusedNode,\n    direction,\n    orientation,\n  });\n\n  if (!navigationStyle) {\n    return null;\n  } else if (navigationStyle.style === 'default') {\n    return defaultNavigation({\n      arrow,\n      focusState,\n      targetNode: navigationStyle.targetNode,\n      direction,\n      orientation,\n    });\n  } else if (navigationStyle.style === 'grid') {\n    return gridNavigation({\n      arrow,\n      focusState,\n      focusedNode,\n      gridNode: navigationStyle.gridNode,\n      rowNode: navigationStyle.rowNode,\n      direction,\n      orientation,\n    });\n  }\n\n  return null;\n}\n","import testForGrid from './test-for-grid';\nimport getGridParent from './get-grid-parent';\nimport getDefaultNavTarget from './get-default-nav-target';\nimport {\n  FocusState,\n  Node,\n  Orientation,\n  Direction,\n  Arrow,\n  Id,\n  GridStyle,\n  DefaultStyle,\n} from '../../types';\n\ninterface DetermineNavigationStyleOptions {\n  focusState: FocusState;\n  orientation: Orientation;\n  direction: Direction;\n  focusedNode: Node;\n  arrow: Arrow;\n}\n\ninterface ProcessNodeOptions {\n  focusState: FocusState;\n  orientation: Orientation;\n  direction: Direction;\n  node: Node;\n  arrow: Arrow;\n}\n\nfunction processNode({\n  arrow,\n  focusState,\n  node,\n  direction,\n  orientation,\n}: ProcessNodeOptions): GridStyle | DefaultStyle | null {\n  // This is the operative line of code that makes focus traps function.\n  // When a trap node is encountered, we return null, which signifies\n  // no navigation at all.\n  // Without this check, this function start traversing up the tree outside of the focus\n  // trap, which could potentially cause focus to leave the trap.\n  if (node.trap) {\n    return null;\n  }\n\n  const parentId = node.parentId as Id;\n  const parentNode = focusState.nodes[parentId];\n\n  if (!parentNode) {\n    return null;\n  }\n\n  const isGridNode =\n    node.nodeNavigationItem === 'grid-item' ||\n    node.nodeNavigationItem === 'grid-row';\n\n  if (isGridNode) {\n    const gridHandle = testForGrid({\n      focusState,\n      focusedNode: node,\n      direction,\n      orientation,\n    });\n\n    if (!gridHandle) {\n      const activeGridNodes = getGridParent({ focusState, focusedNode: node });\n\n      if (activeGridNodes) {\n        return processNode({\n          arrow,\n          focusState,\n          node: activeGridNodes.gridNode,\n          direction,\n          orientation,\n        });\n      }\n    } else {\n      return gridHandle;\n    }\n  }\n\n  const defaultNavigationTargetNode = getDefaultNavTarget(\n    focusState,\n    node,\n    orientation,\n    direction\n  );\n\n  if (defaultNavigationTargetNode) {\n    return {\n      style: 'default',\n      targetNode: defaultNavigationTargetNode,\n    };\n  }\n\n  return processNode({\n    arrow,\n    focusState,\n    node: parentNode,\n    direction,\n    orientation,\n  });\n}\n\nexport default function determineNavigationStyle({\n  arrow,\n  focusState,\n  focusedNode,\n  direction,\n  orientation,\n}: DetermineNavigationStyleOptions) {\n  const result = processNode({\n    arrow,\n    focusState,\n    node: focusedNode,\n    direction,\n    orientation,\n  });\n\n  return result;\n}\n","import getGridParent from './get-grid-parent';\nimport {\n  FocusState,\n  Node,\n  Orientation,\n  Direction,\n  GridStyle,\n} from '../../types';\n\nexport default function testForGrid({\n  focusState,\n  focusedNode,\n  orientation,\n  direction,\n}: {\n  focusState: FocusState;\n  focusedNode: Node;\n  orientation: Orientation;\n  direction: Direction;\n}): GridStyle | null {\n  const activeGridNodes = getGridParent({ focusState, focusedNode });\n\n  if (!activeGridNodes) {\n    return null;\n  }\n\n  const { gridNode, rowNode } = activeGridNodes;\n\n  const isVertical = orientation === 'vertical';\n  const isForward = direction === 'forward';\n\n  const currentRowIndex = gridNode._gridRowIndex ?? 0;\n  const currentColumnIndex = gridNode._gridColumnIndex ?? 0;\n\n  const actualRowIndex = Math.min(\n    currentRowIndex,\n    gridNode.children.length - 1\n  );\n\n  const actualColumnIndex = Math.min(\n    currentColumnIndex,\n    rowNode.children.length - 1\n  );\n\n  const isAtFirstRow = gridNode._gridRowIndex === 0;\n  const isAtLastRow = actualRowIndex === gridNode.children.length - 1;\n\n  const isAtFirstColumn = gridNode._gridColumnIndex === 0;\n  const isAtLastColumn = actualColumnIndex === rowNode.children.length - 1;\n\n  const movingBackwardVerticallyOnFirstRow =\n    isVertical && !isForward && isAtFirstRow;\n  const movingForwardVerticallyOnLastRow =\n    isVertical && isForward && isAtLastRow;\n\n  const movingBackwardHorizontallyOnFirstColumn =\n    !isVertical && !isForward && isAtFirstColumn;\n  const movingForwardHorizontallyOnLastColumn =\n    !isVertical && isForward && isAtLastColumn;\n\n  const wouldHandleVertical =\n    gridNode.wrapGridVertical ||\n    (!movingBackwardVerticallyOnFirstRow && !movingForwardVerticallyOnLastRow);\n  const wouldHandleHorizontal =\n    gridNode.wrapGridHorizontal ||\n    (!movingBackwardHorizontallyOnFirstColumn &&\n      !movingForwardHorizontallyOnLastColumn);\n\n  const movementIsWithinTheGrid =\n    (isVertical && wouldHandleVertical) ||\n    (!isVertical && wouldHandleHorizontal);\n\n  if (movementIsWithinTheGrid) {\n    return {\n      style: 'grid',\n      gridNode,\n      rowNode,\n    };\n  } else {\n    return null;\n  }\n}\n","import nodeCanReceiveIndirectFocus from '../../utils/node-can-receive-indirect-focus';\nimport { FocusState, Node, Orientation, Direction, Id } from '../../types';\n\nexport default function getDefaultNavTarget(\n  focusState: FocusState,\n  node: Node,\n  orientation: Orientation,\n  direction: Direction\n) {\n  const parentId = node.parentId as Id;\n  const parentNode = focusState.nodes[parentId];\n\n  if (!parentNode) {\n    return null;\n  }\n\n  if (parentNode.orientation === orientation) {\n    if (parentNode.wrapping) {\n      return node;\n    } else {\n      const unfilteredChildren = parentNode.children || [];\n\n      // We only consider children nodes that can receive focus via arrows\n      const parentsChildren = unfilteredChildren.filter((nodeId) => {\n        const node = focusState.nodes[nodeId];\n\n        if (!nodeCanReceiveIndirectFocus(focusState, node)) {\n          return false;\n        }\n\n        return true;\n      });\n\n      const index = parentsChildren.indexOf(node.focusId);\n\n      // This is true when pressing the \"forward\" key (right or down) and focus is\n      // on the *last* item in the list of children. For example:\n      // _ _ _ X\n      const movingForwardAndOnLastNode =\n        direction === 'forward' && index === parentsChildren.length - 1;\n\n      // This is true when pressing the \"backward\" key (left or up) and focus is\n      // on the *first* item in the list of children. For example:\n      // X _ _ _\n      const movingBackwardAndOnFirstNode =\n        direction === 'backward' && index === 0;\n\n      if (movingForwardAndOnLastNode || movingBackwardAndOnFirstNode) {\n        return null;\n      }\n\n      // If that is not true, then focus will remain within this parent and we return the node.\n      else {\n        return node;\n      }\n    }\n  } else {\n    return null;\n  }\n}\n","import navigateFromTargetNode from './navigate-from-target-node';\nimport { FocusState, Node, Orientation, Direction, Arrow } from '../../types';\nimport updateFocus from '../../update-focus/update-focus';\n\ninterface DefaultNavigationOptions {\n  focusState: FocusState;\n  orientation: Orientation;\n  direction: Direction;\n  targetNode: Node;\n  arrow: Arrow;\n}\n\nexport default function defaultNavigation({\n  focusState,\n  orientation,\n  targetNode,\n  direction,\n  arrow,\n}: DefaultNavigationOptions): FocusState | null {\n  const result = navigateFromTargetNode({\n    focusState,\n    targetNode,\n    direction,\n  });\n\n  if (!result) {\n    return null;\n  }\n\n  const newState = updateFocus({\n    focusState,\n    orientation,\n    assignFocusTo: result.newFocusedId,\n    preferEnd: result.preferEnd,\n  });\n\n  let parentNode: Node | null = null;\n  if (targetNode.parentId) {\n    parentNode = newState.nodes[targetNode.parentId] ?? null;\n  }\n\n  const stateChanged = newState !== focusState;\n\n  if (stateChanged && parentNode && typeof parentNode.onMove === 'function') {\n    const nextChildIndex = parentNode.focusedChildIndex as number;\n    const prevChildIndex = parentNode.prevFocusedChildIndex;\n\n    const currentFocusedNodeId = parentNode.children[nextChildIndex];\n    const currentFocusedNode = newState.nodes[currentFocusedNodeId] as Node;\n\n    const prevFocusedNodeId =\n      prevChildIndex === null ? null : parentNode.children[prevChildIndex];\n    const prevFocusedNode =\n      prevFocusedNodeId === null ? null : newState.nodes[prevFocusedNodeId];\n\n    parentNode.onMove({\n      orientation,\n      direction,\n      arrow,\n      node: parentNode,\n      prevChildIndex,\n      nextChildIndex,\n      prevChildNode: prevFocusedNode ?? null,\n      nextChildNode: currentFocusedNode,\n    });\n  }\n\n  return newState;\n}\n","import { Node, FocusState, Direction, Id } from '../../types';\nimport getIndex from '../../utils/get-index';\n\ninterface NavigateReturn {\n  newFocusedId: Id;\n  preferEnd: boolean;\n}\n\nexport default function navigateFromTargetNode({\n  focusState,\n  targetNode,\n  direction,\n}: {\n  focusState: FocusState;\n  targetNode: Node;\n  direction: Direction;\n}): NavigateReturn | null {\n  const parentId = targetNode.parentId as Id;\n  const parentNode = focusState.nodes[parentId];\n\n  if (!parentNode) {\n    return null;\n  }\n\n  const distance = direction === 'forward' ? 1 : -1;\n  const wrapping = parentNode.wrapping;\n  const preferEnd = direction === 'forward' ? false : true;\n\n  const targetNodeId = targetNode.focusId;\n\n  const allParentsChildren = parentNode.children || [];\n\n  const parentsChildren = allParentsChildren.filter((nodeId) => {\n    const node = focusState.nodes[nodeId];\n\n    if (!node) {\n      return false;\n    }\n\n    const isEnabled = !node.disabled;\n    const isExiting = node.isExiting;\n    const canReceiveFocusFromArrow = !node.trap;\n\n    return isEnabled && !isExiting && canReceiveFocusFromArrow;\n  });\n\n  const index = parentsChildren.indexOf(targetNodeId);\n\n  const newIndex = getIndex(parentsChildren.length, index + distance, wrapping);\n  const newFocusedId = parentsChildren[newIndex];\n  const newFocusedNode = focusState.nodes[newFocusedId];\n\n  // Disabled/exiting nodes cannot receive focus\n  if (!newFocusedNode || newFocusedNode.disabled || newFocusedNode.isExiting) {\n    return null;\n  }\n\n  return {\n    newFocusedId,\n    preferEnd,\n  };\n}\n","import { FocusState, Node, Orientation, Direction, Arrow } from '../../types';\nimport getGridFocusData from '../../utils/get-grid-focus-data';\nimport updateFocus from '../../update-focus/update-focus';\n\ninterface GridNavigationOptions {\n  focusState: FocusState;\n  orientation: Orientation;\n  direction: Direction;\n  focusedNode: Node;\n  gridNode: Node;\n  rowNode: Node;\n  arrow: Arrow;\n}\n\nexport default function gridNavigation({\n  focusState,\n  orientation,\n  gridNode,\n  rowNode,\n  direction,\n  arrow,\n}: GridNavigationOptions): FocusState | null {\n  const gridFocusData = getGridFocusData({\n    focusState,\n    orientation,\n    direction,\n    gridNode,\n    rowNode,\n  });\n\n  if (!gridFocusData) {\n    return null;\n  }\n\n  const {\n    targetFocusId,\n    currentRowIndex,\n    currentColumnIndex,\n    newRowIndex,\n    newColumnIndex,\n  } = gridFocusData;\n\n  const updatedFocusTree = updateFocus({\n    focusState,\n    orientation,\n    assignFocusTo: targetFocusId,\n    preferEnd: false,\n  });\n\n  // TODO: maybe add a check here to verify this is true?\n  const updatedGridNode = updatedFocusTree.nodes[gridNode.focusId] as Node;\n\n  const rowChanged = currentRowIndex !== newRowIndex;\n  const columnChanged = currentColumnIndex !== newColumnIndex;\n\n  const changeOccurred = rowChanged || columnChanged;\n  if (changeOccurred && typeof gridNode.onGridMove === 'function') {\n    gridNode.onGridMove({\n      orientation,\n      direction,\n      arrow,\n      gridNode,\n\n      prevRowIndex: currentRowIndex,\n      nextRowIndex: newRowIndex,\n\n      prevColumnIndex: currentColumnIndex,\n      nextColumnIndex: newColumnIndex,\n\n      // TODO: add these\n      // currentRowNode,\n      // nextRowNode,\n      // currentItemNode,\n      // nextItemNode\n    });\n  }\n\n  const newState = {\n    ...updatedFocusTree,\n    nodes: {\n      ...updatedFocusTree.nodes,\n      [gridNode.focusId]: {\n        ...updatedGridNode,\n        _gridColumnIndex: newColumnIndex,\n        _gridRowIndex: newRowIndex,\n      },\n    },\n  };\n\n  return newState;\n}\n","import getIndex from './get-index';\nimport { Id, Orientation, Direction, Node, FocusState } from '../types';\n\ninterface GetGridFocusDataReturn {\n  targetFocusId: Id;\n  currentRowIndex: number;\n  currentColumnIndex: number;\n  newRowIndex: number;\n  newColumnIndex: number;\n}\n\nexport default function getGridFocusData({\n  focusState,\n  orientation,\n  direction,\n  gridNode,\n  rowNode,\n}: {\n  focusState: FocusState;\n  orientation: Orientation;\n  direction: Direction;\n  gridNode: Node;\n  rowNode: Node;\n}): GetGridFocusDataReturn | null {\n  const isVertical = orientation === 'vertical';\n  const isForward = direction === 'forward';\n\n  const currentRowIndex = gridNode._gridRowIndex ?? 0;\n  const currentColumnIndex = gridNode._gridColumnIndex ?? 0;\n\n  const actualRowIndex = Math.min(\n    currentRowIndex,\n    gridNode.children.length - 1\n  );\n\n  const actualColumnIndex = Math.min(\n    currentColumnIndex,\n    rowNode.children.length - 1\n  );\n\n  const distance = isForward ? 1 : -1;\n  const newRowIndex = isVertical\n    ? getIndex(\n        gridNode.children.length,\n        actualRowIndex + distance,\n        gridNode.wrapGridVertical\n      )\n    : actualRowIndex;\n  const newColumnIndex = !isVertical\n    ? getIndex(\n        rowNode.children.length,\n        actualColumnIndex + distance,\n        gridNode.wrapGridHorizontal\n      )\n    : currentColumnIndex;\n\n  const newRowNodeId = gridNode.children[newRowIndex];\n  const newRowNode = focusState.nodes[newRowNodeId];\n\n  if (!newRowNode) {\n    return null;\n  }\n\n  const itemIndex = Math.min(newColumnIndex, newRowNode.children.length - 1);\n  const newItemNodeId = newRowNode.children[itemIndex];\n\n  if (newItemNodeId === null) {\n    return null;\n  }\n\n  return {\n    targetFocusId: newItemNodeId,\n    currentRowIndex,\n    currentColumnIndex,\n    newRowIndex,\n    newColumnIndex,\n  };\n}\n","import throttle from './throttle';\nimport keyToBindingMap from './key-to-binding-map';\nimport { FocusStore } from '../types';\n\nexport default function focusLrud(focusStore: FocusStore) {\n  const lrudMapping = {\n    up() {\n      focusStore.processKey.up();\n    },\n\n    down() {\n      focusStore.processKey.down();\n    },\n\n    left() {\n      focusStore.processKey.left();\n    },\n\n    right() {\n      focusStore.processKey.right();\n    },\n\n    select() {\n      focusStore.processKey.select();\n    },\n\n    back() {\n      focusStore.processKey.back();\n    },\n  };\n\n  \n  function subscribe(throttleDelay:number) {\n    const keydownHandler = throttle(\n      function (e: KeyboardEvent) {\n        // @ts-ignore\n        const bindingName = keyToBindingMap[e.key];\n        // @ts-ignore\n        const binding = lrudMapping[bindingName];\n  \n        if (typeof binding === 'function') {\n          e.preventDefault();\n          e.stopPropagation();\n  \n          binding();\n        }\n      },\n      // TODO: support throttling. Ideally on a per-node basis.\n      throttleDelay,\n      {\n        trailing: false,\n      }\n    );\n    window.addEventListener('keydown', keydownHandler);\n\n    function unsubscribe() {\n      window.removeEventListener('keydown', keydownHandler);\n    }\n\n    return unsubscribe\n  }\n\n\n  return {\n    subscribe,\n  };\n}\n","interface Options {\n  leading?: boolean;\n  trailing?: boolean;\n}\n\nexport default function throttle(\n  func: (e: any) => void,\n  wait: number,\n  options?: Options\n) {\n  // @ts-ignore\n  var context, args, result;\n  // @ts-ignore\n  var timeout = null;\n  var previous = 0;\n  if (!options) options = {};\n\n  var later = function () {\n    // @ts-ignore\n    previous = options.leading === false ? 0 : Date.now();\n    timeout = null;\n    // @ts-ignore\n    result = func.apply(context, args);\n    if (!timeout) context = args = null;\n  };\n\n  return function () {\n    var now = Date.now();\n    // @ts-ignore\n    if (!previous && options.leading === false) previous = now;\n    var remaining = wait - (now - previous);\n    // @ts-ignore\n    context = this;\n    args = arguments;\n    if (remaining <= 0 || remaining > wait) {\n      // @ts-ignore\n      if (timeout) {\n        // @ts-ignore\n        clearTimeout(timeout);\n        timeout = null;\n      }\n      previous = now;\n      // @ts-ignore\n      result = func.apply(context, args);\n      // @ts-ignore\n      if (!timeout) context = args = null;\n      // @ts-ignore\n    } else if (!timeout && options.trailing !== false) {\n      timeout = setTimeout(later, remaining);\n    }\n    // @ts-ignore\n    return result;\n  };\n}\n","import { useEffect, useRef } from 'react';\n\nexport default function usePrevious<Value>(value: Value): Value | undefined {\n  const ref = useRef<Value>();\n\n  useEffect(() => {\n    ref.current = value;\n  });\n\n  return ref.current;\n}\n","import React, {\n  createElement,\n  useState,\n  useImperativeHandle,\n  useContext,\n  useEffect,\n  useRef,\n  useMemo,\n  forwardRef,\n} from 'react';\nimport FocusContext from './focus-context';\nimport nodeFromDefinition from './utils/node-from-definition';\nimport { warning } from './utils/warning';\nimport usePrevious from './hooks/internal/use-previous';\nimport {\n  FocusStore,\n  Id,\n  FocusNodeProps,\n  Node,\n  FocusNode as FocusNodeType,\n  NodeDefinition,\n  ProviderValue,\n  ReactNodeRef,\n} from './types';\n\nlet uniqueId = 0;\n\nfunction checkForUpdate({\n  focusStore,\n  id,\n  setNode,\n  currentNode,\n}: {\n  focusStore: FocusStore;\n  id: Id;\n  setNode: React.Dispatch<React.SetStateAction<FocusNodeType>>;\n  currentNode: Node;\n}) {\n  const state = focusStore.getState();\n  const newNode = state.nodes[id] as FocusNodeType;\n\n  if (newNode && newNode !== currentNode && !newNode.isExiting) {\n    setNode(newNode);\n  }\n}\n\nexport function FocusNode(\n  {\n    elementType = 'div',\n\n    focusId,\n    className = '',\n    children,\n    wrapping = false,\n    wrapGridHorizontal,\n    wrapGridVertical,\n    orientation,\n    isGrid = false,\n    isTrap = false,\n    forgetTrapFocusHierarchy = false,\n\n    defaultFocusColumn,\n    defaultFocusRow,\n\n    disabled,\n\n    onMountAssignFocusTo,\n    defaultFocusChild,\n\n    isExiting = false,\n\n    propsFromNode,\n\n    focusedClass = 'isFocused',\n    focusedLeafClass = 'isFocusedLeaf',\n    disabledClass = 'focusDisabled',\n    activeClass = 'isActive',\n\n    onKey,\n    onArrow,\n    onLeft,\n    onRight,\n    onUp,\n    onDown,\n    onSelected,\n    onBack,\n\n    onMove,\n    onGridMove,\n\n    onFocused,\n    onBlurred,\n\n    onClick,\n    onMouseOver,\n\n    ...otherProps\n  }: FocusNodeProps,\n  ref: ReactNodeRef\n) {\n  const elRef = useRef(null);\n\n  // We store the callbacks in a ref so that we can pass a wrapper function into the underlying\n  // focus node within the focus state. This wrapper function stays constant throughout the lifetime\n  // of the node, and that wrapper calls this ref.\n  // The reason for this roundabout solution is to avoid a situation of an infinite rerenders: if the node\n  // itself were updated when the callbacks changed, then this would cause all consumers of the store state\n  // to render. Unless consumers are using `useCallback`, this would recreate the handlers, creating an infinite\n  // loop.\n  const callbacksRef = useRef({\n    onKey,\n    onArrow,\n    onLeft,\n    onRight,\n    onUp,\n    onDown,\n    onSelected,\n    onBack,\n\n    onMove,\n    onGridMove,\n\n    onFocused,\n    onBlurred,\n\n    onClick,\n    onMouseOver,\n  });\n\n  useEffect(() => {\n    callbacksRef.current = {\n      onKey,\n      onArrow,\n      onLeft,\n      onRight,\n      onUp,\n      onDown,\n      onSelected,\n      onBack,\n\n      onMove,\n      onGridMove,\n\n      onFocused,\n      onBlurred,\n\n      onClick,\n      onMouseOver,\n    };\n  }, [\n    onKey,\n    onArrow,\n    onLeft,\n    onRight,\n    onUp,\n    onDown,\n    onSelected,\n    onBack,\n\n    onMove,\n    onGridMove,\n\n    onFocused,\n    onBlurred,\n\n    onClick,\n    onMouseOver,\n  ]);\n\n  useImperativeHandle(\n    ref,\n    // I may need to update this based on this comment to make TS happy:\n    // https://github.com/DefinitelyTyped/DefinitelyTyped/issues/46266#issuecomment-662543885\n    // However, this code works as expected so I'm @ts-ignoring it.\n    // @ts-ignore\n    () => {\n      return elRef.current;\n    }\n  );\n\n  const [nodeId] = useState(() => {\n    const nonStringFocusId =\n      typeof focusId !== 'string' && focusId !== undefined;\n    const reservedFocusId = focusId === 'root';\n    const emptyStringNode = focusId + '' === '';\n    const invalidNodeId =\n      nonStringFocusId || reservedFocusId || emptyStringNode;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (reservedFocusId) {\n        warning(\n          'A focus node with an invalid focus ID was created: \"root\". This is a reserved ID, so it has been ' +\n            'ignored. Please choose another ID if you wish to specify an ID.',\n          'ROOT_ID_WAS_PASSED'\n        );\n      }\n\n      if (nonStringFocusId || emptyStringNode) {\n        warning(\n          'A focus node with an invalid (non-string or empty string) focus ID was created. This is a not supported ID type (expected non-empty string), so it has been ' +\n            'ignored. Please choose another ID if you wish to specify an ID.',\n          'INVALID_FOCUS_ID_PASSED'\n        );\n      }\n    }\n\n    if (focusId && !invalidNodeId) {\n      return focusId;\n    } else {\n      const id = `node-${uniqueId}`;\n      uniqueId = uniqueId + 1;\n\n      return id;\n    }\n  });\n\n  const onClickRef = useRef(onClick);\n  const onMouseOverRef = useRef(onMouseOver);\n\n  onClickRef.current = onClick;\n  onMouseOverRef.current = onMouseOver;\n\n  const defaultForgetFocusTrap = isTrap ? false : undefined;\n  const defaultOrientation = !isGrid ? undefined : 'horizontal';\n\n  const contextValue = useContext(FocusContext.Context);\n  const [staticDefinitions] = useState(() => {\n    const wrapGridVerticalValue =\n      typeof wrapGridVertical === 'boolean' ? wrapGridVertical : wrapping;\n    const wrapGridHorizontalValue =\n      typeof wrapGridHorizontal === 'boolean' ? wrapGridHorizontal : wrapping;\n\n    function createCallbackWrapper(fnName: string) {\n      return function callbackWrapper(...args: any[]) {\n        // @ts-ignore\n        if (\n          callbacksRef.current &&\n          // @ts-ignore\n          typeof callbacksRef.current[fnName] === 'function'\n        ) {\n          // @ts-ignore\n          callbacksRef.current[fnName](...args);\n        }\n      };\n    }\n\n    const nodeDefinition: NodeDefinition = {\n      elRef,\n      focusId: nodeId,\n      orientation: orientation || defaultOrientation,\n      wrapping: Boolean(wrapping),\n      trap: Boolean(isTrap),\n      wrapGridHorizontal: wrapGridHorizontalValue,\n      wrapGridVertical: wrapGridVerticalValue,\n      forgetTrapFocusHierarchy:\n        forgetTrapFocusHierarchy !== undefined\n          ? forgetTrapFocusHierarchy\n          : defaultForgetFocusTrap,\n      navigationStyle: isGrid ? 'grid' : 'first-child',\n\n      defaultFocusColumn: defaultFocusColumn ?? 0,\n      defaultFocusRow: defaultFocusRow ?? 0,\n\n      onKey: createCallbackWrapper('onKey'),\n      onArrow: createCallbackWrapper('onArrow'),\n      onLeft: createCallbackWrapper('onLeft'),\n      onRight: createCallbackWrapper('onRight'),\n      onUp: createCallbackWrapper('onUp'),\n      onDown: createCallbackWrapper('onDown'),\n      onSelected: createCallbackWrapper('onSelected'),\n      onBack: createCallbackWrapper('onBack'),\n\n      onMove: createCallbackWrapper('onMove'),\n      onGridMove: createCallbackWrapper('onGridMove'),\n\n      initiallyDisabled: Boolean(disabled),\n      onMountAssignFocusTo,\n      defaultFocusChild,\n\n      isExiting,\n\n      onFocused,\n      onBlurred,\n    };\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (isGrid && orientation) {\n        warning(\n          'You passed the orientation prop to a grid focus node. ' +\n            'This prop has no effect on grid nodes, but it may represent an error in your code. ' +\n            `This node has a focus ID of ${nodeId}.`,\n          'ORIENTATION_ON_GRID'\n        );\n      }\n\n      if (isGrid && defaultFocusChild) {\n        warning(\n          'You passed the defaultFocusChild prop to a grid focus node. ' +\n            'This prop has no effect on grid nodes, but it may represent an error in your code. ' +\n            `This node has a focus ID of ${nodeId}.`,\n          'PREFERRED_CHILD_INDEX_ON_GRID'\n        );\n      }\n\n      if (onGridMove && !isGrid) {\n        warning(\n          'You passed the onGridMove prop to a node that is not a grid. ' +\n            'This will have no effect, but it may represent an error in your code. ' +\n            `This node has a focus ID of ${nodeId}.`,\n          'GRID_MOVE_NOT_ON_GRID'\n        );\n      } else if (onMove && isGrid) {\n        warning(\n          'You passed the onMove prop to a grid Focus Node. ' +\n            'onMove does not work on grid nodes. Did you mean to pass onGridMove instead? ' +\n            `This node has a focus ID of ${nodeId}.`,\n          'ON_MOVE_ON_GRID'\n        );\n      }\n\n      if (forgetTrapFocusHierarchy && !nodeDefinition.trap) {\n        warning(\n          'You passed the forgetTrapFocusHierarchy prop to a focus node that is not a trap. ' +\n            'This will have no effect, but it may represent an error in your code. ' +\n            `This node has a focus ID of ${nodeId}.`,\n          'RESTORE_TRAP_FOCUS_WITHOUT_TRAP'\n        );\n      }\n    }\n\n    if (!contextValue) {\n      if (process.env.NODE_ENV !== 'production') {\n        warning(\n          'A FocusProvider was not found in the tree. Did you forget to mount it?',\n          'NO_FOCUS_PROVIDER_DETECTED'\n        );\n      }\n\n      throw new Error('No FocusProvider.');\n    }\n\n    const { store, focusDefinitionHierarchy, focusNodesHierarchy } =\n      contextValue;\n\n    const parentNode = focusNodesHierarchy[focusNodesHierarchy.length - 1];\n    const initialNode = nodeFromDefinition({\n      nodeDefinition,\n      parentNode,\n    });\n\n    const newDefinitionHierarchy =\n      focusDefinitionHierarchy.concat(nodeDefinition);\n\n    const newNodesHierarchy = focusNodesHierarchy.concat(initialNode);\n\n    const providerValue: ProviderValue = {\n      store,\n      focusDefinitionHierarchy: newDefinitionHierarchy,\n      focusNodesHierarchy: newNodesHierarchy,\n    };\n\n    return {\n      nodeDefinition,\n      initialNode,\n      providerValue,\n    };\n  });\n\n  const { store } = contextValue as ProviderValue;\n\n  const [node, setNode] = useState<FocusNodeType>(() => {\n    return staticDefinitions.initialNode;\n  });\n\n  const computedProps = useMemo(() => {\n    if (typeof propsFromNode === 'function') {\n      return propsFromNode(node);\n    }\n    return {};\n  }, [node, propsFromNode]);\n\n  const nodeRef = useRef(node);\n  nodeRef.current = node;\n\n  let nodeExistsInTree = useRef(false);\n\n  const dynamicProps = useMemo(() => {\n    return {\n      disabled: Boolean(disabled),\n      isExiting: Boolean(isExiting),\n      defaultFocusColumn,\n      defaultFocusRow,\n      wrapping,\n      trap: isTrap,\n      forgetTrapFocusHierarchy,\n      defaultFocusChild,\n    };\n  }, [\n    disabled,\n    isExiting,\n    defaultFocusColumn,\n    defaultFocusRow,\n    wrapping,\n    isTrap,\n    forgetTrapFocusHierarchy,\n    defaultFocusChild,\n  ]);\n\n  const prevDynamicProps = usePrevious(dynamicProps);\n\n  useEffect(() => {\n    // This ensures that we don't check for updates on the first render.\n    if (!nodeExistsInTree.current) {\n      return;\n    }\n\n    const actualUpdate = {};\n    let hasUpdate = false;\n\n    for (let x in dynamicProps) {\n      // @ts-ignore\n      const currentProp = dynamicProps[x];\n      // @ts-ignore\n      const prevProp = prevDynamicProps[x];\n\n      if (currentProp !== prevProp) {\n        hasUpdate = true;\n        // @ts-ignore\n        actualUpdate[x] = currentProp;\n      }\n    }\n\n    if (hasUpdate) {\n      store.updateNode(nodeId, actualUpdate);\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [dynamicProps, prevDynamicProps]);\n\n  useEffect(() => {\n    store.createNodes(\n      staticDefinitions.providerValue.focusNodesHierarchy,\n      staticDefinitions.providerValue.focusDefinitionHierarchy\n    );\n    nodeExistsInTree.current = true;\n\n    const unsubscribe = store.subscribe(() =>\n      checkForUpdate({\n        focusStore: store,\n        id: nodeId,\n        setNode,\n        currentNode: nodeRef.current,\n      })\n    );\n\n    // We need to manually check for updates. This is because parent nodes won't receive the update otherwise.\n    // By the time a parent's useEffect runs, their children will have already instantiated them, so the store\n    // will not call \"update\" as a result of `.createNodes()`\n    checkForUpdate({\n      focusStore: store,\n      id: nodeId,\n      setNode,\n      currentNode: nodeRef.current,\n    });\n\n    return () => {\n      nodeExistsInTree.current = false;\n      store.deleteNode(nodeId);\n      unsubscribe();\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  const classNameString = `${className} ${node.isFocused ? focusedClass : ''} ${\n    node.isFocusedLeaf ? focusedLeafClass : ''\n  } ${node.disabled ? disabledClass : ''} ${\n    computedProps && typeof computedProps.className === 'string'\n      ? computedProps.className\n      : ''\n  } ${node.active ? activeClass : ''}`;\n\n  return (\n    <FocusContext.Context.Provider value={staticDefinitions.providerValue}>\n      {createElement(elementType, {\n        ...otherProps,\n        ...computedProps,\n        ref: elRef,\n        className: classNameString,\n        children,\n        onMouseOver(e: any) {\n          // We only set focus via mouse to the leaf nodes that aren't disabled\n          const focusState = staticDefinitions.providerValue.store.getState();\n\n          if (\n            nodeRef.current &&\n            nodeRef.current.children.length === 0 &&\n            !nodeRef.current.disabled &&\n            focusState._hasPointerEventsEnabled &&\n            focusState.interactionMode === 'pointer' &&\n            nodeExistsInTree.current\n          ) {\n            staticDefinitions.providerValue.store.setFocus(nodeId);\n          }\n\n          if (typeof onMouseOverRef.current === 'function') {\n            onMouseOverRef.current(e);\n          }\n        },\n        onClick(e: any) {\n          if (typeof onClickRef.current === 'function') {\n            onClickRef.current(e);\n          }\n\n          const isLeaf =\n            nodeRef.current && nodeRef.current.children.length === 0;\n          const isDisabled = nodeRef.current && nodeRef.current.disabled;\n          if (!isLeaf || isDisabled) {\n            return;\n          }\n\n          const focusState = staticDefinitions.providerValue.store.getState();\n\n          if (\n            !focusState._hasPointerEventsEnabled ||\n            !nodeExistsInTree.current ||\n            focusState.interactionMode !== 'pointer'\n          ) {\n            return;\n          }\n\n          if (\n            nodeRef.current &&\n            typeof nodeRef.current.onSelected === 'function'\n          ) {\n            // Note: `bubbleKey` fires the events up whatever the current focus hierarchy is, so it might seem\n            // weird that we can just assume that this node is always the leaf node of the current hierarchy.\n            //\n            // It turns out that this works because:\n            //   - when pointer events are enabled we always set focus to leaf nodes in `onMouseOver`\n            //   - this lib is not intended for touchscreen environments, so all click events will be preceded by a hover\n            //   - these pointer events are only handled on leaf nodes\n            //\n            // If any of those conditions ever change then we will need to revisit this, but for now it should be fine.\n            staticDefinitions.providerValue.store.processKey.select();\n          }\n\n          staticDefinitions.providerValue.store.handleSelect(nodeId);\n        },\n      })}\n    </FocusContext.Context.Provider>\n  );\n}\n\nconst ForwardedFocusNode = forwardRef(FocusNode);\nexport default ForwardedFocusNode;\n","import { FocusNode, NodeDefinition, Node, NodeNavigationItem } from '../types';\n\nexport default function nodeFromDefinition({\n  nodeDefinition,\n  parentNode,\n}: {\n  nodeDefinition: NodeDefinition;\n  parentNode: Node;\n}) {\n  const {\n    elRef,\n    onKey,\n    onArrow,\n    onLeft,\n    onRight,\n    onUp,\n    onDown,\n    onSelected,\n    onBack,\n\n    onFocused,\n    onBlurred,\n\n    defaultFocusColumn,\n    defaultFocusRow,\n\n    isExiting = false,\n\n    onMove,\n    onGridMove,\n  } = nodeDefinition;\n\n  const parentId = parentNode.focusId;\n  let nodeNavigationItem: NodeNavigationItem = 'default';\n\n  if (nodeDefinition.navigationStyle === 'grid') {\n    nodeNavigationItem = 'grid-container';\n  } else if (parentNode && parentNode.navigationStyle === 'grid') {\n    nodeNavigationItem = 'grid-row';\n  } else if (parentNode && parentNode.nodeNavigationItem === 'grid-row') {\n    nodeNavigationItem = 'grid-item';\n  }\n\n  const navigationStyle = nodeDefinition.navigationStyle ?? 'first-child';\n  const isGridContainer = navigationStyle === 'grid';\n\n  const defaultFocusColumnValue = defaultFocusColumn ?? 0;\n  const defaultFocusRowValue = defaultFocusRow ?? 0;\n\n  const node: FocusNode = {\n    elRef,\n    focusId: nodeDefinition.focusId,\n    isRoot: false,\n    parentId,\n\n    isExiting,\n\n    // These will be updated to their actual values within the call to `createNodes` below.\n    isFocused: false,\n    isFocusedLeaf: false,\n    active: false,\n\n    trap: Boolean(nodeDefinition.trap),\n    orientation: nodeDefinition.orientation ?? 'horizontal',\n    wrapping: Boolean(nodeDefinition.wrapping),\n    disabled: Boolean(nodeDefinition.initiallyDisabled),\n    navigationStyle,\n    nodeNavigationItem,\n    defaultFocusChild: nodeDefinition.defaultFocusChild,\n\n    defaultFocusColumn: defaultFocusColumnValue,\n    defaultFocusRow: defaultFocusRowValue,\n\n    forgetTrapFocusHierarchy: Boolean(\n      nodeDefinition.forgetTrapFocusHierarchy ?? false\n    ),\n    children: [],\n    focusedChildIndex: null,\n    prevFocusedChildIndex: null,\n    _gridColumnIndex: isGridContainer ? defaultFocusColumnValue : null,\n    _gridRowIndex: isGridContainer ? defaultFocusRowValue : null,\n    wrapGridHorizontal: Boolean(nodeDefinition.wrapGridHorizontal),\n    wrapGridVertical: Boolean(nodeDefinition.wrapGridVertical),\n    _focusTrapPreviousHierarchy: [],\n\n    onKey,\n    onArrow,\n    onLeft,\n    onRight,\n    onUp,\n    onDown,\n    onSelected,\n    onBack,\n\n    onFocused,\n    onBlurred,\n\n    onMove,\n    onGridMove,\n  };\n\n  return node;\n}\n","import { useContext, useState, useEffect, useRef } from 'react';\nimport FocusContext from '../focus-context';\nimport { warning } from '../utils/warning';\nimport { Id, Node } from '../types';\n\nexport default function useFocusNodeById(focusId: Id): Node | null {\n  const contextValue = useContext(FocusContext.Context);\n\n  const [focusNode, setFocusNode] = useState<Node | null>(() => {\n    if (!contextValue) {\n      if (process.env.NODE_ENV !== 'production') {\n        warning(\n          'A FocusProvider was not found in the tree. Did you forget to mount it?',\n          'NO_FOCUS_PROVIDER_DETECTED'\n        );\n      }\n\n      return null;\n    } else {\n      if (process.env.NODE_ENV !== 'production') {\n        if (typeof focusId !== 'string') {\n          warning(\n            `You passed a non-string focus ID to useFocusNodeById: ${focusId}. Focus IDs are always strings. ` +\n              'This may represent an error in your code.',\n            'FOCUS_ID_NOT_STRING'\n          );\n        }\n      }\n\n      const focusState = contextValue.store.getState();\n      const possibleNode = focusState.nodes[focusId];\n      return possibleNode ?? null;\n    }\n  });\n\n  const focusNodeRef = useRef(focusNode);\n  focusNodeRef.current = focusNode;\n\n  const focusIdRef = useRef(focusId);\n  focusIdRef.current = focusId;\n\n  function checkForSync() {\n    if (!contextValue) {\n      return;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof focusIdRef.current !== 'string') {\n        warning(\n          `You passed a non-string focus ID to useFocusNodeById: ${focusId}. Focus IDs are always strings. ` +\n            'This may represent an error in your code.',\n          'FOCUS_ID_NOT_STRING'\n        );\n      }\n    }\n\n    const currentNode =\n      contextValue.store.getState().nodes[focusIdRef.current] ?? null;\n    if (currentNode !== focusNodeRef.current) {\n      setFocusNode(currentNode);\n    }\n  }\n\n  useEffect(checkForSync, [focusId]);\n\n  useEffect(() => {\n    if (!contextValue) {\n      return;\n    }\n\n    checkForSync();\n    const unsubscribe = contextValue.store.subscribe(checkForSync);\n\n    return () => {\n      unsubscribe();\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  return focusNode;\n}\n","import { useContext, useEffect, useState, useRef } from 'react';\nimport FocusContext from '../focus-context';\nimport { warning } from '../utils/warning';\nimport { Node, NodeHierarchy } from '../types';\n\nfunction hierarchiesAreEqual(\n  old: Node[] = [],\n  current: NodeHierarchy = []\n): boolean {\n  // Hierarchies are only equal when the lengths are the same, and...\n  if (old.length !== current.length) {\n    return false;\n  }\n\n  const oldFocusedExact = old[old.length - 1] || {};\n\n  // ...when the last IDs match\n  if (oldFocusedExact.focusId !== current[current.length - 1]) {\n    return false;\n  }\n\n  return true;\n}\n\nexport default function useFocusHierarchy(): Node[] {\n  const contextValue = useContext(FocusContext.Context);\n\n  const [focusHierarchy, setFocusHierarchy] = useState<Node[]>(() => {\n    if (!contextValue) {\n      if (process.env.NODE_ENV !== 'production') {\n        warning(\n          'A FocusProvider was not found in the tree. Did you forget to mount it?',\n          'NO_FOCUS_PROVIDER_DETECTED'\n        );\n      }\n      return [];\n    } else {\n      const focusState = contextValue.store.getState();\n      return focusState.focusHierarchy.map(\n        (nodeId) => focusState.nodes[nodeId]\n      ) as Node[];\n    }\n  });\n\n  const focusHierarchyRef = useRef(focusHierarchy);\n  focusHierarchyRef.current = focusHierarchy;\n\n  function checkForSync() {\n    if (!contextValue) {\n      return;\n    }\n\n    const currentState = contextValue.store.getState();\n\n    const currentHierarchy = contextValue.store.getState().focusHierarchy;\n    if (!hierarchiesAreEqual(focusHierarchyRef.current, currentHierarchy)) {\n      setFocusHierarchy(\n        currentState.focusHierarchy.map(\n          (nodeId) => currentState.nodes[nodeId]\n        ) as Node[]\n      );\n    }\n  }\n\n  useEffect(() => {\n    if (!contextValue) {\n      return;\n    }\n\n    checkForSync();\n    const unsubscribe = contextValue.store.subscribe(checkForSync);\n\n    return () => {\n      unsubscribe();\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  return focusHierarchy;\n}\n","import { useContext } from 'react';\nimport FocusContext from '../focus-context';\nimport { warning } from '../utils/warning';\nimport { FocusStore } from '../types';\n\nexport default function useFocusStoreDangerously(): FocusStore {\n  const contextValue = useContext(FocusContext.Context);\n\n  if (!contextValue) {\n    if (process.env.NODE_ENV !== 'production') {\n      warning(\n        'A FocusProvider was not found in the tree. Did you forget to mount it?',\n        'NO_FOCUS_PROVIDER_DETECTED'\n      );\n    }\n\n    throw new Error('No FocusProvider.');\n  }\n\n  // @ts-ignore\n  return contextValue.store;\n}\n","import { useEffect } from 'react';\nimport usePrevious from './use-previous';\n\ntype ComparatorFn<Value> = (a: Value, b: Value | undefined) => boolean;\n\nconst isEqual: ComparatorFn<any> = (a, b) => a === b;\n\nexport default function useChange<Value>(\n  val: Value,\n  callback: (currentValue: Value, previousValue: Value | undefined) => void,\n  comparator: ComparatorFn<Value> = isEqual\n): void {\n  const previous = usePrevious(val);\n\n  useEffect(() => {\n    if (typeof callback === 'function' && typeof comparator === 'function') {\n      if (!comparator(val, previous)) {\n        callback(val, previous);\n      }\n    }\n  }, [val, previous, comparator, callback]);\n}\n","import FocusContext from './focus-context';\nexport { default as FocusNode } from './focus-node';\nexport { default as useFocusNodeById } from './hooks/use-focus-node-by-id';\nexport { default as useFocusNode } from './hooks/use-focus-node';\nexport { default as useLeafFocusedNode } from './hooks/use-leaf-focused-node';\nexport { default as useActiveNode } from './hooks/use-active-node';\nexport { default as useFocusHierarchy } from './hooks/use-focus-hierarchy';\nexport { default as useFocusStoreDangerously } from './hooks/use-focus-store-dangerously';\nexport { default as useSetFocus } from './hooks/use-set-focus';\nexport { default as useFocusEvents } from './hooks/use-focus-events';\nexport { default as useProcessKey } from './hooks/use-process-key';\n\nconst FocusRoot = FocusContext.FocusRoot;\nexport { FocusRoot };\n","import { useContext, useState, useEffect, useRef } from 'react';\nimport FocusContext from '../focus-context';\nimport { warning } from '../utils/warning';\nimport { Node } from '../types';\n\nexport default function useActiveNode(): Node | null {\n  const contextValue = useContext(FocusContext.Context);\n\n  const [focusNode, setFocusNode] = useState<Node | null>(() => {\n    if (!contextValue) {\n      if (process.env.NODE_ENV !== 'production') {\n        warning(\n          'A FocusProvider was not found in the tree. Did you forget to mount it?',\n          'NO_FOCUS_PROVIDER_DETECTED'\n        );\n      }\n\n      return null;\n    } else {\n      const focusState = contextValue.store.getState();\n\n      if (focusState.activeNodeId === null) {\n        return null;\n      }\n\n      const possibleNode = focusState.nodes[focusState.activeNodeId];\n      return possibleNode ?? null;\n    }\n  });\n\n  const focusNodeRef = useRef(focusNode);\n  focusNodeRef.current = focusNode;\n\n  function checkForSync() {\n    if (!contextValue) {\n      return;\n    }\n\n    const currentState = contextValue.store.getState();\n\n    if (!currentState.activeNodeId) {\n      setFocusNode(null);\n      return;\n    }\n\n    const currentNode = currentState.nodes[currentState.activeNodeId] ?? null;\n    if (currentNode !== focusNodeRef.current) {\n      setFocusNode(currentNode);\n    }\n  }\n\n  useEffect(() => {\n    if (!contextValue) {\n      return;\n    }\n\n    checkForSync();\n    const unsubscribe = contextValue.store.subscribe(checkForSync);\n\n    return () => {\n      unsubscribe();\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  return focusNode;\n}\n","import { useRef, useState } from 'react';\nimport useOnChange from './internal/use-on-change';\nimport useFocusNodeById from './use-focus-node-by-id';\nimport { warning } from '../utils/warning';\nimport { Id, Node } from '../types';\n\ntype EventCallback = (node: Node) => void;\n\ninterface Events {\n  focus?: EventCallback;\n  blur?: EventCallback;\n\n  active?: EventCallback;\n  inactive?: EventCallback;\n\n  disabled?: EventCallback;\n  enabled?: EventCallback;\n}\n\nexport default function useFocusEvents(nodeId: Id, events: Events = {}): void {\n  const [constantNodeId] = useState(nodeId);\n\n  const node = useFocusNodeById(constantNodeId);\n  const nodeRef = useRef(node);\n  nodeRef.current = node;\n\n  const eventsRef = useRef(events);\n  eventsRef.current = events;\n\n  // This pattern allows the `focus` hook to be called even on mount.\n  // When the node doesn't exist, we set this to false. Then, when the initial\n  // mounting is done, `node.isFocused` is true, and the callbacks fire.\n  const isFocused = Boolean(node && node.isFocused);\n\n  // This ensures that the enabled/disabled hooks are *not* called on mount.\n  // This way, `disabled/enabled` are only called when that state actually changes\n  let isDisabled;\n  if (!node) {\n    isDisabled = null;\n  } else {\n    isDisabled = node.disabled;\n  }\n\n  // For active, we also wouldn't want it to be called on mount, but it's not possible\n  // for a node to be mounted as active, so this simpler logic gives us the desired behavior.\n  const isActive = Boolean(node && node.active);\n\n  useOnChange(nodeId, (currentId, prevId) => {\n    if (typeof prevId !== 'string') {\n      return;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (currentId !== prevId) {\n        warning(\n          `The nodeId passed into useFocusEvents changed. This change has been ignored: the nodeId cannot be changed.`,\n          'FOCUS_EVENTS_NODE_ID_CHANGED'\n        );\n      }\n    }\n  });\n\n  useOnChange(isFocused, (currentIsFocused) => {\n    if (nodeRef.current) {\n      if (currentIsFocused && typeof eventsRef.current.focus === 'function') {\n        eventsRef.current.focus(nodeRef.current);\n      } else if (\n        !currentIsFocused &&\n        typeof eventsRef.current.blur === 'function'\n      ) {\n        eventsRef.current.blur(nodeRef.current);\n      }\n    }\n  });\n\n  useOnChange(isDisabled, (currentIsDisabled, prevIsDisabled) => {\n    if (prevIsDisabled === undefined || prevIsDisabled == null) {\n      return;\n    }\n\n    if (nodeRef.current) {\n      if (\n        currentIsDisabled &&\n        typeof eventsRef.current.disabled === 'function'\n      ) {\n        eventsRef.current.disabled(nodeRef.current);\n      } else if (\n        !currentIsDisabled &&\n        typeof eventsRef.current.enabled === 'function'\n      ) {\n        eventsRef.current.enabled(nodeRef.current);\n      }\n    }\n  });\n\n  useOnChange(isActive, (currentIsActive) => {\n    if (nodeRef.current) {\n      if (currentIsActive && typeof eventsRef.current.active === 'function') {\n        eventsRef.current.active(nodeRef.current);\n      } else if (\n        !currentIsActive &&\n        typeof eventsRef.current.inactive === 'function'\n      ) {\n        eventsRef.current.inactive(nodeRef.current);\n      }\n    }\n  });\n}\n","import { useEffect } from 'react';\nimport { warning } from '../utils/warning';\nimport useFocusNodeById from './use-focus-node-by-id';\nimport { Id, Node } from '../types';\n\nexport default function useFocusNode(nodeId: Id): Node | null {\n  useEffect(() => {\n    warning(\n      `You used the hook \\`useFocusNode\\`. This hook has been renamed to \\`useFocusNodeById\\`. Please refactor your code to use the new hook instead.`,\n      'USE_FOCUS_NODE_RENAMED'\n    );\n  }, []);\n\n  return useFocusNodeById(nodeId);\n}\n","import { useMemo } from 'react';\nimport { Node } from '../types';\nimport useFocusHierarchy from './use-focus-hierarchy';\nimport useFocusNodeById from './use-focus-node-by-id';\n\nexport default function useLeafFocusedNode(): Node | null {\n  const focusHierarchy = useFocusHierarchy();\n\n  const leafId = useMemo(() => {\n    return focusHierarchy?.[focusHierarchy.length - 1]?.focusId;\n  }, [focusHierarchy]);\n\n  const leafFocusedNode = useFocusNodeById(leafId ?? '');\n\n  return leafFocusedNode;\n}\n","import useFocusStoreDangerously from './use-focus-store-dangerously';\n\nexport default function useProcessKey() {\n  const focusStore = useFocusStoreDangerously();\n  return focusStore.processKey;\n}\n","import { useContext } from 'react';\nimport FocusContext from '../focus-context';\nimport { warning } from '../utils/warning';\nimport { Id } from '../types';\n\nexport default function useSetFocus(): (focusId: Id) => void {\n  const contextValue = useContext(FocusContext.Context);\n\n  if (!contextValue) {\n    if (process.env.NODE_ENV !== 'production') {\n      warning(\n        'A FocusProvider was not found in the tree. Did you forget to mount it?',\n        'NO_FOCUS_PROVIDER_DETECTED'\n      );\n    }\n\n    throw new Error('No FocusProvider.');\n  }\n\n  // @ts-ignore\n  return contextValue.store.setFocus;\n}\n"],"names":["clamp","x","min","max","RangeError","getIndex","arrayLength","index","wrap","size","Math","floor","getWrappedIndex","nodeCanReceiveIndirectFocus","focusState","node","disabled","isExiting","trap","children","length","someChildIsEnabled","i","nodes","getParentGrid","rowNode","parentId","columnIndex","filter","nodeId","indexOf","focusId","gridNode","gridChildren","_gridColumnIndex","_gridRowIndex","bubbleEvent","callbackName","arg","nodeIds","reverse","forEach","targetNodeId","cb","currentNode","updateFocus","newFocusHierarchy","assignFocusTo","orientation","preferEnd","propagateFromId","preferredChildren","_focusTrapPreviousHierarchy","getParents","currentFocusHierarchy","getChildren","nodeChildren","childId","nextPreferredChildren","navigationStyle","rowIndex","defaultFocusRow","rowId","row","defaultFocusColumn","columnId","nextChildId","numericdefaultFocusChild","defaultFocusChild","Number","isFinite","possibleId","slice","useLastNode","lastIndex","childIndex","generateFocusHierarchyFromId","focusedNodeId","computeFocusHierarchy","focusHierarchy","prevFocusHierarchy","largerIndex","splitIndex","NaN","isNaN","blur","focus","unchanged","getFocusDiff","newNodes","blurHierarchy","unchangedHierarchy","result","isLastNode","isFocusedLeaf","prevFocusedChildIndex","focusedChildIndex","nodeToUpdate","isFocused","forgetTrapFocusHierarchy","childHierarchy","isLeafNode","nodeNavigationItem","updatedGridNode","getNodesFromFocusChange","newState","_updatingFocusIsLocked","activeNodeId","interactionMode","_hasPointerEventsEnabled","blurNodeId","focusNodeId","blurNode","undefined","focusNode","emitFocusStateEvents","getGridParent","focusedNode","executeFunction","fn","isArrow","key","stopPropagation","preventDefault","targetNode","dynamicNodeProps","ArrowUp","ArrowDown","ArrowLeft","ArrowRight","Enter","Escape","FocusContext","React","createContext","Context","FocusRoot","wrapping","pointerEvents","throttle","rootElRef","useRef","providerValue","useState","store","currentState","root","elRef","current","isRoot","active","wrapGridVertical","wrapGridHorizontal","listeners","onUpdate","listener","isListeningToPointerEvents","handlingPointerEvent","onPointerEvent","requestAnimationFrame","newMode","newFocusState","setInteractionMode","addPointerListeners","window","addEventListener","removePointerListeners","removeEventListener","internalProcessKey","focusTree","state","getState","isSelect","isBack","defaultPrevented","propagationStopped","reverseFocusHierarchy","handleArrow","handleSelect","bubbleKey","_focusStore","subscribe","push","subscribed","splice","createNodes","nodeHierarchy","nodeDefinitionHierarchy","nodeUpdates","onMountAssignFocusToReturn","shouldLockFocus","nodeDefinition","isCreatingNewNode","onMountAssignFocusTo","rowNodeChildrenLength","_rowNode$children","itemIndex","focusedItemId","parentNode","parentChildren","newParentChildren","Array","isArray","concat","Object","keys","createNode","Boolean","possibleNewState","focusedItemIndex","map","assigningFocusOnMount","findIndex","v","updatedFocusState","deleteNode","id","recursivelyDeleteChildren","childNode","childChildren","stateAfterDeletion","nodeIdIsFocused","deleteNodeUtil","setFocus","updateNode","update","updateHasDisabled","updateHasExiting","nodeChanged","some","prop","newNode","updatedChildren","recursiveUpdate","recursivelyUpdateChildren","updatedChildrenNodes","nodeWasFocused","find","updatedState","arrow","direction","processNode","gridHandle","activeGridNodes","isVertical","isForward","currentRowIndex","currentColumnIndex","actualRowIndex","actualColumnIndex","style","testForGrid","defaultNavigationTargetNode","parentsChildren","getDefaultNavTarget","distance","newFocusedId","newFocusedNode","navigateFromTargetNode","onMove","nextChildIndex","prevChildIndex","prevFocusedNodeId","prevFocusedNode","prevChildNode","nextChildNode","defaultNavigation","gridFocusData","newRowIndex","newColumnIndex","newRowNode","newItemNodeId","targetFocusId","getGridFocusData","updatedFocusTree","onGridMove","prevRowIndex","nextRowIndex","prevColumnIndex","nextColumnIndex","gridNavigation","handleArrowUtil","leafNodeId","leafNode","previousActiveNode","configurePointerEvents","enablePointerEvents","destroy","processKey","select","back","down","left","right","up","createFocusStore","focusDefinitionHierarchy","focusNodesHierarchy","useEffect","focusStore","lrudMapping","unsubscribe","throttleDelay","keydownHandler","func","wait","options","context","args","timeout","previous","later","leading","Date","now","apply","remaining","this","arguments","clearTimeout","trailing","setTimeout","e","binding","keyToBindingMap","Provider","value","usePrevious","ref","uniqueId","checkForUpdate","setNode","FocusNode","elementType","className","isGrid","isTrap","propsFromNode","focusedClass","focusedLeafClass","disabledClass","activeClass","onKey","onArrow","onLeft","onRight","onUp","onDown","onSelected","onBack","onFocused","onBlurred","onClick","onMouseOver","otherProps","callbacksRef","useImperativeHandle","onClickRef","onMouseOverRef","defaultForgetFocusTrap","defaultOrientation","contextValue","useContext","staticDefinitions","wrapGridVerticalValue","wrapGridHorizontalValue","createCallbackWrapper","fnName","initiallyDisabled","Error","initialNode","isGridContainer","defaultFocusColumnValue","defaultFocusRowValue","nodeFromDefinition","computedProps","useMemo","nodeRef","nodeExistsInTree","dynamicProps","prevDynamicProps","actualUpdate","hasUpdate","currentProp","createElement","useFocusNodeById","possibleNode","setFocusNode","focusNodeRef","focusIdRef","checkForSync","useFocusHierarchy","setFocusHierarchy","focusHierarchyRef","old","currentHierarchy","useFocusStoreDangerously","isEqual","a","b","useChange","val","callback","comparator","forwardRef","events","eventsRef","isDisabled","isActive","useOnChange","currentId","prevId","currentIsFocused","currentIsDisabled","prevIsDisabled","enabled","currentIsActive","inactive","leafId","_focusHierarchy"],"mappings":"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"}